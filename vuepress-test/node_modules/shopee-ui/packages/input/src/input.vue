<template>
  <div class="shopee-input"
    v-if="type !== 'textarea'" @click="handleClick()">
      <div :class="className">
        <div class="shopee-input__prefix"
        v-if="$slots.prefix || prefixLabel || prefixIcon"
        ref="prefix"><!--
          --><template v-if="prefixLabel">{{prefixLabel}}<span class="shopee-input__prefix-split"></span></template><!--
          --><shopee-icon class="shopee-input__prefix-icon" :svg="prefixIcon" v-if="prefixIcon"></shopee-icon><!--
          --><slot name="prefix" v-if="$slots.prefix"></slot>
        </div>
        <input
          class="shopee-input__input"
          ref="input"
          :type="type"
          :value="currentValue"
          :placeholder="computedPlaceholder"
          v-bind="nativeProps"
          v-on="acturalListeners"
          @focus="handleFocus"
          @blur="handleBlur"
          @compositionend="handleInput"
          @input="handleInput"
          @change="handleChange">
        <div class="shopee-input__suffix"
          v-if="$slots.suffix || suffixLabel || suffixIcon || clearable || isWordLimitVisible"
          ref="suffix"><!--
          --><shopee-icon class="shopee-input__clear-btn" :svg="clearIcon" v-if="!disabled && clearable" @click.native.stop="clear()"></shopee-icon><!--
          --><template v-if="suffixLabel"><span class="shopee-input__suffix-split"></span>{{suffixLabel}}</template><!--
          --><span v-if="!suffixLabel && isWordLimitVisible" class="shopee-input__count">{{ textLength }}/{{ maxlength }}</span><!--
          --><shopee-icon class="shopee-input__suffix-icon" v-if="suffixIcon" :svg="suffixIcon"></shopee-icon><!--
          --><slot name="suffix" v-if="$slots.suffix"></slot>
        </div>
      </div><!--
    --><p class="shopee-input__error-msg" v-if="error && !$slots.error">{{errorMessage}}</p><!--
    --><div class="shopee-input__error-msg" v-if="$slots.error"><slot name="error"></slot></div><!--
    --><p class="shopee-input__help-text" v-if="helpText && !$slots.help">{{helpText}}</p><!--
    --><div class="shopee-input__help-text" v-if="$slots.help"><!--
        --><slot name="help"></slot>
      </div><!--
    --><div class="shopee-input__warning-text" v-if="warningText"><!--
        --><shopee-icon :svg="warningIcon"></shopee-icon>
        {{warningText}}
      </div>
  </div>
  <div v-else class="shopee-input shopee-input__area" @click="handleClick()">
    <textarea
      ref="textarea"
      :class="className"
      :style="textareaStyle"
      :value="currentValue"
      @focus="handleFocus"
      @blur="handleBlur"
      @input="handleInput"
      v-bind="nativeProps"
      v-on="$listeners">
    </textarea><!--
 --><span class="shopee-input__count" v-if="isWordLimitVisible">{{ textLength }}/{{ maxlength }}</span><!--
 --><p class="shopee-input__error-msg" v-if="error && !$slots.error">{{errorMessage}}</p><!--
 --><div class="shopee-input__error-msg" v-if="$slots.error"><slot name="error"></slot></div><!--
 --><p class="shopee-input__help-text" v-if="helpText && !$slots.help">{{helpText}}</p><!--
 --><div class="shopee-input__help-text" v-if="$slots.help"><slot name="help"></slot></div><!--
 --><div class="shopee-input__warning-text" v-if="warningText"><!--
    --><shopee-icon :svg="warningIcon"></shopee-icon>
      {{warningText}}
    </div>
  </div>
</template>
<script>
import { Icon as ShopeeIcon } from 'shopee-ui/lib/icon';
import { EventBusMixin, FormItemMixin, LocaleMixin } from 'shopee-ui/lib/base';
import { isRegExp, lengthOf, sliceStr } from 'shopee-ui/lib/base';
import { valueToFixed } from 'shopee-ui/lib/base';
import { RESTRICTION_TYPE } from 'shopee-ui/lib/base';
import calcTextareaHeight from './calculate-textarea-height';
import clearIcon from '@/static/svg/icon-clear.svg';
import warningIcon from '@shopee-ui/icon/svg/notice-circle-s.svg';

export default {
  name: 'ShopeeInput',
  // prevent duplicate with v-on="$listeners" on input
  model: {
    prop: 'value',
    event: 'value-change'
  },
  components: {
    ShopeeIcon
  },
  mixins: [EventBusMixin, FormItemMixin, LocaleMixin],
  props: {
    type: {
      type: String,
      default: 'text'
    },
    // x-large, large, normal, small
    size: {
      type: String,
      validator(value = 'normal') {
        return ['x-large', 'large', 'normal', 'small'].indexOf(value) >= 0;
      }
    },
    value: {
      type: [String, Number],
      default: ''
    },
    disabled: Boolean,
    clearable: Boolean,
    suspendBeforeClear: [Boolean, Function], //默认在clearable状态下点击X会清空value，若为true则不清空
    placeholder: String,
    name: String,
    resize: {
      type: String,
      default: 'vertical',
      validator(value = 'vertical') {
        return ['vertical', 'both', 'horizontal', 'none'].indexOf(value) >= 0;
      }
    },
    rows: {
      type: Number,
      default: 2
    },
    minrows: {
      type: Number,
      default: 2
    },
    maxrows: Number,
    autosize: Boolean,
    readonly: Boolean,
    required: Boolean,
    autofocus: Boolean,
    autocomplete: String,
    form: String,
    minlength: Number,
    maxlength: Number,
    error: Boolean,
    errorMessage: String,
    prefixLabel: String,
    prefixIcon: String,
    suffixLabel: String,
    suffixIcon: String,
    restriction: [String, Function, RegExp],
    restrictionType: {
      type: String,
      default: RESTRICTION_TYPE.INPUT
    },
    lazy: Boolean,
    helpText: String,
    warningText: String,
    showWordLimit: Boolean,
    precision: {
      type: Number,
      validator(val) {
        return val >= 0 && val === parseInt(val, 10);
      }
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    isRound: Boolean,
    unicodeNormalized: Boolean
  },
  data() {
    return {
      clearIcon,
      warningIcon,
      prefixClass: 'shopee-input',
      currentValue: this.unicodeNormalized ? sliceStr(this.value || '', 0, this.maxlength) : this.value,
      textareaCalcStyle: {},
      focused: false,
      acturalListeners: {}
    };
  },
  computed: {
    className() {
      return [
        `${this.prefixClass}__inner`,
        this.focused ? 'focused' : '',
        this.disabled ? 'disabled' : '',
        this.error ? 'error' : '',
        this.sizeClass ? `${this.prefixClass}__inner--${this.sizeClass}` : '',
        this.clearable && this.currentValue.length > 0 ? 'active-clearable' : ''
      ];
    },
    textareaStyle() {
      return Object.assign({}, this.textareaCalcStyle, {
        resize: this.resize
      });
    },
    nativeProps() {
      const props = {};
      // remove below props when using v-bind at native input
      const removeProps = ['error', 'errorMessage', 'prefixLabel', 'prefixIcon', 'suffixLabel', 'suffixIcon', 'restriction'];
      if (this.unicodeNormalized) {
        removeProps.push('maxlength');
      }
      for (const key in this.$props) {
        if (this.$props.hasOwnProperty(key)) {
          if (removeProps.indexOf(key) === -1) {
            const value = this.$props[key];
            props[key] = typeof value === 'object' ? Object.assign({}, value) : value;
          }
        }
      }
      return props;
    },
    isWordLimitVisible() {
      return this.showWordLimit &&
        this.maxlength &&
        (this.type === 'text' || this.type === 'textarea') &&
        !this.disabled;
    },
    textLength() {
      if (typeof this.currentValue === 'number') {
        return this.lengthOf(String(this.currentValue));
      }

      return this.lengthOf(this.currentValue || '');
    },
    isNumber() {
      return this.type === 'numeric';
    },
    computedRestrictionType() {
      return this.isNumber ? RESTRICTION_TYPE.VALUE : this.restrictionType;
    },
    computedRestriction() {
      const { isNumber, restriction, precision } = this;

      if (restriction) {
        return restriction;
      }

      if (isNumber) {
        const decimalExp = precision === 0 ? '' : '\\.{0,1}';
        const rangExp = precision === undefined ? '*' : `{0,${precision}}`;
        return new RegExp(`^-?(\\d+${decimalExp}\\d${rangExp})?$`);
      }
    },
    computedPlaceholder() {
      const { placeholder, precision, isNumber } = this;
      const base = 0;

      return isNumber ? placeholder || base.toFixed(precision) : placeholder || this.t('shopee-ui.input.placeholder');
    }
  },
  watch: {
    value(val) {
      this.setCurrentValue(val, 'input', true);
    }
  },
  created() {
    // remove click event
    for (let event in this.$listeners) {
      if (event !== 'click') {
        this.acturalListeners[event] = this.$listeners[event];
      }
    }
  },
  mounted() {
    this.resizeTextarea();
    if (this.isNumber && (this.min || this.max)) {
      this.setCurrentValue(this.currentValue, 'input', true);
    }
  },
  methods: {
    resizeTextarea() {
      var { autosize, type } = this;
      if (type !== 'textarea') {
        return;
      }
      if (!autosize) {
        this.textareaCalcStyle = {
          minHeight: calcTextareaHeight(this.$refs.textarea, this.minrows, this.maxrows).minHeight
        };
        return;
      }
      const minRows = this.minrows;
      const maxRows = this.maxrows;
      this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, minRows, maxRows);
    },
    handleInput(event) {
      // remove the effects of deleteCompositionText input event
      // fix #51: can't input word when using the chinese method in safari
      if (event.inputType === 'deleteCompositionText') {
        return;
      }
      if (this.computedRestriction) {
        const isRestrictInput = this.computedRestrictionType === RESTRICTION_TYPE.INPUT;
        const value = isRestrictInput ? event.data : event.target.value;
        if ((!isRestrictInput || value) && (!this.restrictionTest(value))) {
          // reset input value
          this.$refs.input.value = this.currentValue;
          return;
        }
      }
      this.setCurrentValue(event.target.value);
    },
    handleClick() {
      this.$emit('click');
    },
    handleChange(event) {
      this.setCurrentValue(event.target.value, 'change');
    },
    handleFocus() {
      this.focused = true;
      this.dispatch('ShopeeFormItem', 'field-focus');
    },
    handleBlur() {
      this.focused = false;
      this.setCurrentValue(this.currentValue, 'input', true);
      if (!this.findComponentUpward(['ShopeeDatePicker', 'ShopeeNumberInput', 'ShopeeCascader', 'ShopeeSelect'])) {
        this.dispatch('ShopeeFormItem', 'field-blur', this.currentValue);
      }
    },
    findComponentUpward(componentNames) {
      let parent = this.$parent;
      while (parent && componentNames.indexOf(parent.$options.name) === -1) {
        parent = parent.$parent;
      }
      return parent;
    },
    setCurrentValue(value, trigger = 'input', forceValidate = false) {
      const { type, isNumber, lazy, focused, maxlength, unicodeNormalized } = this;
      // auto truncate of Unicode
      // https://git.garena.com/shopee-sz-fe/vue-ui/-/issues/131
      if (unicodeNormalized && maxlength) {
        value = sliceStr(value, 0, maxlength);

        if (type === 'textarea') {
          this.$refs.textarea.value = value;
        } else {
          this.$refs.input.value = value;
        }
      }

      const formatValue = !focused && isNumber ? this.getNumberValue(value, forceValidate) : value;
      this.currentValue = formatValue;

      if (formatValue !== this.value) {
        if ((trigger === 'input' && !lazy) || (trigger === 'change' && lazy)) {
          // if isNumber, value-change only emit by blur
          // otherwise, value-change only emit by input
          if ((!focused && isNumber || !isNumber) && String(this.value) !== formatValue) {
            value = forceValidate ? formatValue : value;
            this.$emit('value-change', value);
          }
          if (!this.findComponentUpward(['ShopeeDatePicker', 'ShopeeNumberInput'])) {
            this.dispatch('ShopeeFormItem', 'field-change', value);
          }
        }
      }
      this.$nextTick(() => {
        if (this.$refs.textarea) {
          this.resizeTextarea();
        }
      });
    },
    getNumberValue(value, forceValidate = false) {
      const { precision, max, min, focused, isRound } = this;

      // remove front 0
      value = value.toString().replace(/^(-?)(0*)([1-9][\d|.]*?)/, '$1$3');

      if (!focused || forceValidate) {
        if (value >= max) {
          value = valueToFixed(max, precision);
        }
        if (value < min) {
          value = min;
        }
      }

      // toFixed value when over precision or not input
      return isRound ? Number(value).toFixed(precision) : valueToFixed(value, precision);
    },
    /**
     * 默认在clearable状态下点击X会清空value，若为true则不清空
     */
    suspendBeforeClearTest() {
      if (typeof this.suspendBeforeClear === 'function') {
        return this.suspendBeforeClear();
      } else if (typeof this.suspendBeforeClear === 'boolean') {
        return this.suspendBeforeClear;
      } else {
        return false;
      }
    },
    restrictionTest(value) {
      const restriction = this.computedRestriction;
      if (typeof restriction === 'function') {
        return restriction(value);
      } else if (isRegExp(restriction)) {
        return restriction.test(value);
      } else {
        if (restriction === 'number') {
          return /^\d*$/.test(value);
        }
        return true;
      }
    },
    clear() {
      if (this.disabled) {
        return;
      }
      if (!this.suspendBeforeClearTest()) {
        this.setCurrentValue('', this.lazy ? 'change' : 'input');
      }
      this.$emit('clear');
    },
    focus() {
      if (this.disabled) {
        return;
      }
      if (this.type === 'textarea') {
        this.$refs.textarea.focus();
      } else {
        this.$refs.input.focus();
      }
    },
    blur() {
      if (this.type === 'textarea') {
        this.$refs.textarea.blur();
      } else {
        this.$refs.input.blur();
      }
    },
    lengthOf(str) {
      return this.unicodeNormalized ? lengthOf(str) : str.length;
    }
  }
};
</script>
