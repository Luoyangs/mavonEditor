<template>
  <div :class="[
    'shopee-form-item',
    sizeClass ? 'shopee-form-item--' + sizeClass : '',
    error ? 'shopee-form-item--error' : ''
  ]">
    <label :for="labelFor" :class="['shopee-form-item__label', !(label || $slots.label) && 'empty']">
      <span class="shopee-form-item__reqiured" v-if="required">*</span>
      <slot name="label">{{label}}</slot>
    </label>
    <div class="shopee-form-item__control">
      <div class="shopee-form-item__content">
        <slot></slot>
      </div>
      <slot name="error" :error="error" :error-message="errorMessage">
        <transition name="slide-fast">
          <div class="shopee-form-item__error" v-if="error && showMessage && form.showMessage">{{errorMessage}}</div>
        </transition>
      </slot>
      <div class="shopee-form-item__extra" v-if="$slots.extra">
        <slot name="extra"></slot>
      </div>
    </div>
  </div>
</template>
<script>
import { EventBusMixin } from 'shopee-ui/lib/base';
import { noop, isArray, isFunction, debounce, isObject } from 'shopee-ui/lib/base';
import { getModelByPath, getRuleByPath, scrollToError } from './util';

const VALIDATE_STATE = {
  SUCCESS: 'success',
  ERROR: 'error',
  VALIDATING: 'validating',
  DEFAULT: ''
};

export default {
  name: 'ShopeeFormItem',
  mixins: [EventBusMixin],
  props: {
    prop: String,
    label: String,
    rules: [Object, Array],
    for: String,
    required: Boolean,
    // size of item: x-large, large, normal, small
    size: String,
    showMessage: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      // mark whether have been inserted into the form and have prop parameters
      verifiable: false,
      validateState: VALIDATE_STATE.DEFAULT,
      error: false,
      errorMessage: '',
      validateTrigger: ''
    };
  },
  computed: {
    labelFor() {
      return this.for || this.prop;
    },
    form() {
      let parent = this.$parent;
      while (parent && parent.$options.name !== 'ShopeeForm') {
        parent = parent.$parent;
      }
      return parent;
    },
    sizeClass() {
      return this.size || this.form.size;
    },
    fieldValue() {
      if (this.verifiable) {
        const formModel = this.form.model || {};
        const { value, parent } = getModelByPath(formModel, this.prop);
        return {
          $model: value,
          $parent: parent
        };
      }
    },
    fieldRules() {
      if (this.verifiable) {
        const formRules = this.form.rules || {};
        return this.rules || getRuleByPath(formRules, this.prop);
      }
    },
    activedRules() {
      if (this.fieldRules) {
        let rules = this.fieldRules;
        rules = !isArray(rules) ? [rules] : rules;
        return rules.filter(rule => {
          // remove $each rule
          if (rule.$each) {
            return false;
          }
          // set default trigger defined in form
          if (rule.trigger === undefined) {
            rule.trigger = this.form.validateTrigger || '';
          }
          // filter rules with current validate trigger
          return this.triggerFilter(rule, this.validateTrigger);
        });
      }
    },
    validators() {
      return this.activedRules && this.activedRules.map(rule => {
        const validator = Object.values(rule).find(n => isFunction(n));
        if (!validator) {
          console.warn(`[ShopeeUI warn][Form]: should define a validate function in rules for form item: ${this.prop}`);
          return false;
        }
        return this.genAsyncValidator(validator, rule.message);
      }).filter(Boolean);
    },
    debounce() {
      return debounce(n => n(), 50);
    }
  },
  watch: {
    fieldRules(value, oldValue) {
      if (this.form.validateOnRuleChange && value !== oldValue && oldValue !== undefined) {
        this.validate();
      }
    }
  },
  mounted() {
    if (this.prop) {
      this.dispatch('ShopeeForm', 'add-item', this);
      this.verifiable = true;

      if (this.fieldRules) {
        this.$on('field-focus', this.onFieldFocus);
        this.$on('field-blur', this.onFieldBlur);
        this.$on('field-change', this.onFieldChange);
      }
    }
  },
  beforeDestroy() {
    this.dispatch('ShopeeForm', 'remove-item', this);
  },
  methods: {
    triggerFilter(rule, trigger) {
      if (!rule.trigger || !trigger) {
        return true;
      }
      if (isArray(rule.trigger)) {
        return rule.trigger.indexOf(trigger) > -1;
      } else {
        return rule.trigger === trigger;
      }
    },

    genAsyncValidator(validator, message) {
      return async (...args) => {
        const res = await validator(...args);
        const error = !res || Object.prototype.toString.call(res) === '[object Error]';
        return {
          error,
          errorMessage: error ? res.message || message : ''
        };
      };
    },

    async handleValidate(validators) {
      for (let index = 0, length = validators.length; index < length; index++) {
        const validator = validators[index];
        const { error, errorMessage } = await validator(this.fieldValue.$model, this.fieldValue.$parent, this.form.model);
        if (error || index === length - 1) {
          return {
            error,
            errorMessage
          };
        }
      }
    },

    validate(trigger = '', callback = noop, errorHandle) {
      if (isObject(callback)) {
        errorHandle = callback;
      }

      if (isFunction(trigger)) {
        callback = trigger;
        trigger = '';
      } else if (isObject(trigger)) {
        errorHandle = trigger;
        callback = noop;
        trigger = '';
      }

      this.validateTrigger = trigger;

      const validators = this.validators;
      if (!validators || validators.length === 0) {
        callback(true);
        return true;
      }

      this.validateState = VALIDATE_STATE.VALIDATING;
      this.updateError(false);

      return new Promise(async resolve => {
        const { error, errorMessage } = await this.handleValidate(validators);
        this.validateState = !error ? VALIDATE_STATE.SUCCESS : VALIDATE_STATE.ERROR;
        this.updateError(error, errorMessage);
        this.form.$emit('validate', this.prop, !error, this.fieldValue.$model);
        // error handle: scroll to error
        if (errorHandle && error) {
          scrollToError([this], errorHandle);
        }
        resolve(!error);
        if (isFunction(callback)) {
          callback(!error);
        }
      });
    },

    reset() {
      this.validateState = VALIDATE_STATE.DEFAULT;
      this.updateError(false, '');
    },

    updateError(error, errorMessage) {
      this.debounce(() => {
        this.error = error;
        if (errorMessage !== undefined) {
          this.errorMessage = errorMessage;
        }
      });
    },

    clearValidate() {
      this.reset();
    },

    onFieldFocus() {
      this.reset();
    },

    onFieldBlur() {
      this.validate('blur');
    },

    onFieldChange() {
      this.validate('change');
    },
  }
};
</script>
