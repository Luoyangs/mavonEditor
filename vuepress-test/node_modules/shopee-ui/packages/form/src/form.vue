<template>
  <form
    class="shopee-form"
    :class="[
      inline ? 'shopee-form--inline' : '',
      labelPosition ? 'shopee-form--label-' + labelPosition : '',
    ]"
    :autocomplete="autocomplete">
    <slot></slot>
  </form>
</template>
<script>
import { noop, isFunction, isObject } from 'shopee-ui/lib/base';
import { getFieldsByPaths, scrollToError } from './util';

export default {
  name: 'ShopeeForm',
  props: {
    model: Object,
    rules: Object,
    validateTrigger: {
      type: String,
      validator(value = '') {
        return ['', 'change', 'blur'].indexOf(value) >= 0;
      }
    },
    inline: Boolean,
    // right, left, left
    labelPosition: {
      type: String,
      default: 'right',
      validator(value = 'right') {
        return ['right', 'left', 'top'].indexOf(value) >= 0;
      }
    },
    // size of form items: x-large, large, normal, small
    size: String,
    showMessage: {
      type: Boolean,
      default: true
    },
    validateOnRuleChange: {
      type: Boolean,
      default: true
    },
    autocomplete: {
      default: 'off',
      validator(value = 'off') {
        return ['on', 'off'].indexOf(value) >= 0;
      }
    }
  },
  data() {
    return {
      fields: [],
      validateCallbacks: [],
      groupValidateCallbacks: [],
    };
  },
  created() {
    this.$on('add-item', field => {
      if (field.prop) {
        this.fields.push(field);
      }
    });
    this.$on('remove-item', field => {
      const index = this.fields.indexOf(field);
      if (index >= 0) {
        this.fields.splice(index, 1);
      }
    });
  },
  methods: {
    handleValidate(fields, callback = noop, errorHandle) {
      if (isObject(callback)) {
        errorHandle = callback;
        callback = noop;
      }
      return new Promise(resolve => {
        const handleCallback = result => {
          resolve(result);
          if (isFunction(callback)) {
            callback(result);
          }
        };
        let valid = true;
        let invalidFields = [];
        // callback true when validate fields is empty
        if (fields.length === 0) {
          handleCallback({ valid, invalidFields });
          return;
        }
        // callback the validate result when last field validated
        let count = 0;
        fields.forEach((field, index) => {
          field.validate('', res => {
            if (!res) {
              valid = false;
              invalidFields[index] = field;
            }
            if (++count === fields.length) {
              invalidFields = invalidFields.filter(Boolean);
              // error handle: scroll to error
              if (errorHandle && !valid) {
                scrollToError(invalidFields, errorHandle);
              }
              // all finished
              handleCallback({ valid, invalidFields });
            }
          });
        });
      });
    },

    handleClearValidate(fields) {
      fields.forEach(field => {
        field.reset();
      });
    },

    validate(callback, errorHandle) {
      return this.handleValidate(this.fields, callback, errorHandle);
    },

    clearValidate() {
      this.handleClearValidate(this.fields);
    },

    validateFields(props, callback, errorHandle) {
      const fields = getFieldsByPaths(this.fields, props);
      if (fields.length === 0) {
        console.warn('[ShopeeUI warn][Form]: should call validateFields with valid prop string');
      }
      return this.handleValidate(fields, callback, errorHandle);
    },

    clearValidateFields(props) {
      const fields = getFieldsByPaths(this.fields, props);
      if (fields.length === 0) {
        console.warn('[ShopeeUI warn][Form]: should call clearValidateFields with valid prop string');
      }
      this.handleClearValidate(fields);
    }
  }
};
</script>
