<template>
    <div :class="className" v-shopee-clickoutside="clickOutside">
      <shopee-selector
        ref="popperRef"
        :value="displayValue"
        :clearable="clearable"
        :disabled="disabled"
        :placeholder="placeholder"
        :size="size"
        :max-line="maxLine"
        :suffix-icon="suffixIcon"
        @keydown.native.stop.prevent="onKeydown($event)"
        @clear="clear()"
        @click="toggleVisible()"
        tabindex="0">
      </shopee-selector>
      <shopee-popper
        ref="popper"
        :visible="visible"
        :class="popperClass"
        :flippable="popperFlippable"
        :placement="placement"
        :append-to-body="appendToBody">
        <shopee-cascader-menu
          :lists="lists"
          :selected="currentSelected"
          :max-height="maxHeight"
          :max-width="menuMaxWidth"
          @item-select="onMenuItemSelect"></shopee-cascader-menu>
       </shopee-popper>
    </div>
</template>
<script>
import { EventBusMixin, PopperMixin, ShopeeClickoutside } from 'shopee-ui/lib/base';
import { Selector as ShopeeSelector } from 'shopee-ui/lib/selector';
import { Popper as ShopeePopper } from 'shopee-ui/lib/popper';
import CascaderBaseMixin from './mixins/cascader-base';
import {
  getChildrenOfCurrentSelected,
  getOptionsByValue,
  isSelectFinished,
  getOptionByIndex,
  getHoverIndexByOption,
  isOptionDisabled
} from './utils/helper';
import DOWN_ICON from '@shopee-ui/icon/svg/arrow-down.svg';
import ShopeeCascaderMenu from './cascader-menu.vue';

export default {
  name: 'ShopeeCascader',
  directives: {ShopeeClickoutside},
  components: {
    ShopeePopper,
    ShopeeSelector,
    ShopeeCascaderMenu
  },
  mixins: [EventBusMixin, PopperMixin, CascaderBaseMixin],
  props: {
    placement: {
      default: 'bottom-start'
    },
    separator: {
      type: String,
      default: '/'
    },
    // click, hover
    trigger: {
      type: String,
      default: 'click'
    },
    format: Function,
    clearable: Boolean,
    placeholder: String,
    size: { // cascader尺寸
      type: String,
      validator(value = 'normal') {
        return ['large', 'normal', 'small'].indexOf(value) >= 0;
      }
    },
    disabled: Boolean,
    maxHeight: Number,
    menuMaxWidth: Number, // menu的最大宽度，超过此宽度就折行显示，默认320
    maxLine: { // 选择框支持的最多显示行数，支持1～3
      type: Number,
      validator(value = 1) {
        return [1, 2, 3].indexOf(value) >= 0;
      },
      default: 1
    }
  },
  data() {
    return {
      prefixClass: 'shopee-cascader',
      visible: false,
      suffixIcon: DOWN_ICON,
      hoverIndex: -1,
      hoverLevel: 0
    };
  },
  computed: {
    className() {
      return [
        this.prefixClass,
        this.visible ? 'is-show' : '',
      ];
    },
    displayValue() {
      let selectedOptions = getOptionsByValue(this.options, this.value);
      if (this.format) {
        return this.format(selectedOptions);
      }
      return selectedOptions.map(option => option.label).join(this.separator);
    }
  },
  methods: {
    onKeydown(event) {
      let direct = '';
      let keyCode = event.keyCode || event.which;
      if (keyCode === 40) {
        direct = 'down';
      } else if (keyCode === 38) {
        direct = 'up';
      } else if (keyCode === 39) {
        direct = 'next';
      } else if (keyCode === 37) {
        direct = 'prev';
      } else if (keyCode === 13) {
        this.selectOption();
      } else {
        return;
      }
      this.navigation(direct);
    },
    navigation(direct) {
      if (direct === 'down') {
        if (!this.visible) {
          this.show();
          return;
        }
      }
      // ignore keydown when menu is hidden
      if (!this.visible) {
        return;
      }
      let nextHoverIndex = 0;
      let nextHoverLevel = 0;
      let currentLevelOptionsLength = getChildrenOfCurrentSelected(this.options, this.currentSelected.slice(0, this.currentSelected.length - 1)).length;
      if (direct === 'down') {
        nextHoverIndex = (this.hoverIndex + 1 + currentLevelOptionsLength) % currentLevelOptionsLength;
        nextHoverLevel = this.hoverLevel;
      } else if (direct === 'up') {
        nextHoverIndex = (this.hoverIndex - 1 + currentLevelOptionsLength) % currentLevelOptionsLength;
        nextHoverLevel = this.hoverLevel;
      } else if (direct === 'next') {
        nextHoverIndex = 0;
        nextHoverLevel = this.hoverLevel + 1;
      } else {
        if (this.hoverLevel === 0) {
          return;
        }
        nextHoverIndex = getHoverIndexByOption(this.options, this.currentSelected, this.hoverLevel - 1);
        nextHoverLevel = this.hoverLevel - 1;
      }
      this.hoverIndex = nextHoverIndex;
      // get next active option
      let nextOption = getOptionByIndex(this.options, this.currentSelected, nextHoverLevel, nextHoverIndex);
      if (nextOption) {
        if (isOptionDisabled(nextOption)) {
          if (direct === 'next' || direct === 'prev') {
            this.hoverLevel = nextHoverLevel;
            this.hoverIndex = 0;
            this.navigation('down');
          } else {
            this.navigation(direct);
          }
          return;
        }
        this.hoverLevel = nextHoverLevel;
        this.resetCurrentSelected({
          ...nextOption,
          level: this.hoverLevel
        });
        if (direct === 'up' || direct === 'down') {
          // only emit change when the selection is not finished, otherwise emit change by enter key down
          if (!isSelectFinished(this.options, this.currentSelected)) {
            this.emitCurrentSelect();
          }
        }
      }
    },
    emitCurrentSelect() {
      // emit change
      if (this.changeOnSelect) {
        this.emit(this.currentSelected);
        if (isSelectFinished(this.options, this.currentSelected)) {
          this.hide();
        }
      } else if (isSelectFinished(this.options, this.currentSelected)) {
        this.emit(this.currentSelected);
        this.hide();
      }
    },
    selectOption() {
      if (isSelectFinished(this.options, this.currentSelected)) {
        this.emitCurrentSelect();
        this.hoverIndex = -1;
        this.hoverLevel = 0;
      }
    },
    resetCurrentSelected(option) {
      if (this.currentSelected[option.level] !== undefined) {
        // reset selected value
        this.currentSelected = this.currentSelected.filter((value, index) => {
          if (index <= option.level) {
            return true;
          }
        });
        this.currentSelected.splice(option.level, 1, option.value);
      } else {
        // add current value to selected value
        this.currentSelected.push(option.value);
      }
    },
    onMenuItemSelect(option) {
      if (this.trigger === option.trigger) {
        this.resetCurrentSelected(option);
      }
      if (option.trigger === 'click') {
        this.emitCurrentSelect();
      }
    },
    hide() {
      this.visible = false;
      this.$emit('visible-change', false);
    },
    show() {
      if (this.disabled) {
        return;
      }
      this.currentSelected = (this.value || []).map(item => item) || [];
      this.visible = true;
      this.$emit('visible-change', true);
    },
    clickOutside() {
      if (this.visible) {
        this.hide();
        this.dispatch('ShopeeFormItem', 'field-blur', this.value);
      }
    },
    toggleVisible() {
      if (this.visible) {
        this.hide();
      } else {
        this.show();
      }
    },
    clear() {
      this.$emit('clear');
      this.emit([]);
      this.hide();
    }
  }
};
</script>
