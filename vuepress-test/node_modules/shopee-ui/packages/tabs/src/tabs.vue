<template>
  <div :class="[
    'shopee-tabs',
    {
      ['shopee-tabs-' + type]: type,
      ['shopee-tabs-' + size]: size,
      ['shopee-tabs-' + tabPosition]: tabPosition,
      ['shopee-tabs--scroll-prev']: scrollable && scrollable.prev,
      ['shopee-tabs--scroll-next']: scrollable && scrollable.next,
      ['shopee-tabs--scroll-both']: scrollable && scrollable.prev && scrollable.next
    }
  ]">
    <div class="shopee-tabs__nav">
      <div class="shopee-tabs__nav-prev" v-if="scrollable && scrollable.prev">
        <shopee-icon @click.native="scrollPrev" :svg="arrowLeftIcon"></shopee-icon>
      </div>
      <div class="shopee-tabs__nav-next" v-if="scrollable && scrollable.next">
        <shopee-icon @click.native="scrollNext" :svg="arrowRightIcon"></shopee-icon>
      </div>
      <div class="shopee-tabs__nav-warp" ref="navScroll">
        <div class="shopee-tabs__nav-tabs" :style="navStyle" ref="nav">
          <div
            v-for="(tab, index) in tabList"
            :key="index"
            :class="[
              'shopee-tabs__nav-tab',
              {
                'disabled': tab.disabled,
                'active': tab.active
              }
            ]"
            :style="genLabelStyle(tab)"
            @click="handleClick(tab)">
            <!-- <slot v-if="tab.labelSlot" name="label"></slot> -->
            <Render v-if="tab.labelSlot" :as="tab.labelSlot"></Render>
            <template v-else>{{tab.label}}</template>
            <shopee-icon class="shopee-tabs-close" v-if="tab.showClose" :svg="closeIcon" @click.native.stop="handleRemove(tab)"></shopee-icon>
          </div>
        </div>
        <div class="shopee-tabs__ink-bar" v-if="type === 'line'" :style="barStyle"></div>
      </div>
      <div class="shopee-tabs__nav-extra" v-if="$slots.extra"><slot name="extra"></slot></div>
    </div>
    <div class="shopee-tabs__content" ref="panes">
      <slot></slot>
    </div>
  </div>
</template>
<script>
import { Icon as ShopeeIcon } from 'shopee-ui/lib/icon';
import { Render } from 'shopee-ui/lib/base';
import closeIcon from '@shopee-ui/icon/svg/close.svg';
import arrowLeftIcon from '@shopee-ui/icon/svg/arrow-left.svg';
import arrowRightIcon from '@shopee-ui/icon/svg/arrow-right.svg';

export default {
  name: 'ShopeeTabs',
  components: {
    ShopeeIcon,
    Render
  },
  props: {
    value: String,
    // line, card
    type: {
      type: String,
      default: 'line',
      validator(value = 'line') {
        return ['line', 'card', 'module'].indexOf(value) >= 0;
      }
    },
    // top, bottom, left, right
    tabPosition: {
      type: String,
      default: 'top',
      validator(value = 'top') {
        return ['top', 'bottom', 'left', 'right'].indexOf(value) >= 0;
      }
    },
    size: {
      type: String,
      default: 'normal',
      validator(value = 'normal') {
        return ['normal', 'small'].indexOf(value) >= 0;
      }
    },
    closable: Boolean,
    forceUpdateLabel: Boolean,
    beforeRemove: Function,
    beforeTabClick: Function
  },
  data() {
    return {
      activeTab: this.value || 0,
      tabList: [],
      children: this.$children,
      barStyle: {},
      navOffset: 0,
      scrollable: false,
      navRef: null,
      navScrollRef: null,
      closeIcon,
      arrowLeftIcon,
      arrowRightIcon
    };
  },
  computed: {
    navStyle() {
      return {
        transform: `translate${this.dirName}(-${this.navOffset}px)`
      };
    },
    sizeName() {
      return ['top', 'bottom'].indexOf(this.tabPosition) !== -1 ? 'Width' : 'Height';
    },
    dirName() {
      return ['top', 'bottom'].indexOf(this.tabPosition) !== -1 ? 'X' : 'Y';
    }
  },
  watch: {
    value(value) {
      this.activeTab = value;
    },
    children(value) {
      this.tabList = value.filter(n => n.$options.name === 'ShopeeTabPane');
    },
    activeTab() {
      if (this.navRef) {
        this.$nextTick(() => {
          this.updateInkBarStyle();
          this.scrollToActiveTab();
        });
      }
    },
    tabList() {
      this.updateInkBarStyle();
    },
    navOffset(value) {
      this.$nextTick(() => {
        const { sizeName, tabList, navRef, navScrollRef, tabPosition } = this;
        const activeTab = tabList.find(n => n.active);
        if (!activeTab) {
          this.barStyle = {};
        }

        const tabElements = navRef.querySelectorAll('.shopee-tabs__nav-tab');
        const isHorizonal = ['top', 'bottom'].indexOf(tabPosition) !== -1;
        const containerSize = isHorizonal ? parseFloat(navScrollRef.offsetWidth) : parseFloat(navScrollRef.clientHeight);
        let left = isHorizonal ? parseFloat(tabElements[activeTab.index].offsetLeft) : parseFloat(tabElements[activeTab.index].offsetTop);
        const tabSize = isHorizonal ? parseFloat(tabElements[activeTab.index].offsetWidth) : parseFloat(tabElements[activeTab.index].clientHeight);
        if (value + containerSize === value) {
          left -= value;
        }

        this.barStyle = {
          [`${sizeName.toLowerCase()}`]: `${tabSize}px`,
          transform: `translate${this.dirName}(${left - value}px)`
        };
      });
    }
  },
  updated() {
    this.update();
  },
  mounted() {
    this.navRef = this.$refs.nav;
    this.navScrollRef = this.$refs.navScroll;
    this.$nextTick(() => {
      this.update();
      this.scrollToActiveTab();
    });
  },
  methods: {
    genLabelStyle(tab) {
      const { type, size, tabPosition } = this;
      const { labelMaxWidth } = tab;
      const styles = {};

      if (type === 'line' && size === 'normal' && !['left', 'right'].includes(tabPosition)) {
        styles.whiteSpace = 'normal';
      }

      if (labelMaxWidth !== undefined) {
        styles.maxWidth = `${labelMaxWidth}px`;
      }

      return styles;
    },
    handleClick(tab) {
      if (tab.disabled) {
        return;
      }
      const toTab = tab.tabKey;
      if (!this.beforeTabClick) {
        return this.handleTabClick(toTab);
      }

      const before = this.beforeTabClick(this.activeTab, toTab);
      if (before) {
        if (before.then) {
          before.then(() => {
            this.handleTabClick(toTab);
          });
        } else {
          this.handleTabClick(toTab);
        }
      }
    },
    handleTabClick(tab) {
      this.activeTab = tab;
      this.$emit('input', tab);
      this.$emit('tab-click', tab);
    },
    scrollPrev() {
      const { navOffset, navScrollRef, sizeName } = this;
      const containerSize = navScrollRef[`offset${sizeName}`];

      if (!navOffset) {
        return;
      }

      this.navOffset = navOffset > containerSize ? navOffset - containerSize : 0;
    },
    scrollNext() {
      const { navOffset, navRef, navScrollRef, sizeName } = this;
      const navSize = navRef[`offset${sizeName}`];
      const containerSize = navScrollRef[`offset${sizeName}`];
      // nav-prev/nav-next width
      const actionWidth = 80;

      if (navSize - navOffset <= containerSize) {
        return;
      }

      this.navOffset = navSize - navOffset > containerSize * 2 ? navOffset + containerSize - actionWidth * 2 : navSize - containerSize;
    },
    handleRemove(tab) {
      if (tab.disabled) {
        return;
      }
      if (!this.beforeRemove) {
        return this.handleRemoveTab(tab);
      }
      const before = this.beforeRemove(tab.name);
      if (before) {
        if (before.then) {
          before.then(() => {
            this.handleRemoveTab(tab);
          });
        } else {
          this.handleRemoveTab(tab);
        }
      }
    },
    handleRemoveTab(tab) {
      if (tab.tabKey === this.activeTab) {
        const nextTab = this.tabList.filter(n => n.index > tab.index).find(n => !n.disabled);
        const prevTab = this.tabList.filter(n => n.index < tab.index).reverse().find(n => !n.disabled);
        this.activeTab = nextTab ? nextTab.tabKey : prevTab ? prevTab.tabKey : -1;
      }
      this.$nextTick(() => {
        tab.$destroy();
        this.$emit('tab-remove', tab.tabKey);
      });
    },
    scrollToActiveTab() {
      const { scrollable, tabList, navOffset, navRef, navScrollRef } = this;
      if (!scrollable) {
        return;
      }

      const tabElements = navRef.querySelectorAll('.shopee-tabs__nav-tab');
      const activeTab = tabList.find(n => n.active);
      if (!activeTab) {
        return;
      }

      const activeTabBounding = tabElements[activeTab.index].getBoundingClientRect();
      const navScrollBounding = navScrollRef.getBoundingClientRect();
      const maxOffset = navRef.offsetWidth - navScrollBounding.width;
      let newOffset = navOffset;

      if (activeTabBounding.left < navScrollBounding.left) {
        newOffset = navOffset - (navScrollBounding.left - activeTabBounding.left);
      }
      if (activeTabBounding.right > navScrollBounding.right) {
        newOffset = navOffset + activeTabBounding.right - navScrollBounding.right;
      }

      newOffset = Math.max(newOffset, 0);
      this.navOffset = Math.min(newOffset, maxOffset);
    },
    /**
     * 此方法名请不要改动，业务中手动调用了该方法更新异步接口数据展示
     */
    updateInkBarStyle() {
      if (this.type !== 'line') {
        return;
      }
      this.$nextTick(() => {
        const { sizeName, tabList, navOffset, navRef } = this;
        const activeTab = tabList.find(n => n.active);
        if (!activeTab) {
          this.barStyle = {};
          return;
        }

        let offset = 0;
        let tabSize = 0;
        const tabElements = navRef.querySelectorAll('.shopee-tabs__nav-tab');
        tabList.every((tab, index) => {
          let $el = tabElements[index];
          if (!$el) { return false; }

          if (!tab.active) {
            offset += $el[`client${sizeName}`];
            return true;
          } else {
            tabSize = $el[`client${sizeName}`];
            return false;
          }
        });

        this.barStyle = {
          [`${sizeName.toLowerCase()}`]: `${tabSize}px`,
          transform: `translate${this.dirName}(${offset - navOffset}px)`
        };

      });
    },
    update() {
      const { sizeName, navOffset, navRef, navScrollRef } = this;
      if (!navRef) {
        return;
      }
      const navSize = navRef[`offset${sizeName}`];
      const containerSize = navScrollRef[`offset${sizeName}`];
      if (navSize > containerSize) {
        this.scrollable = this.scrollable || {};
        this.$set(this.scrollable, 'prev', navOffset > 0);
        this.$set(this.scrollable, 'next', navOffset + containerSize < navSize);

        if (navOffset + containerSize > navSize) {
          this.navOffset = navSize - containerSize;
        }
      } else {
        this.scrollable = false;
        if (navOffset > 0) {
          this.navOffset = 0;
        }
      }
    }
  }
};
</script>
