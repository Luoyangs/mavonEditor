<template>
  <div class="shopee-scrollbar">
    <div ref="wrapper" class="shopee-scrollbar__wrapper"
      :style="fixedStyle.wrapper"
      @scroll="onScroll($event)">
      <bar
        ref="verticalBar"
        vertical
        :offset="offsetY"
        :size="heightSize"
        :manual="hoverVisible"
        v-if="!hidden && layout.indexOf('vertical') > -1"></bar>
      <bar
        ref="horizontalBar"
        :offset="offsetX"
        :size="widthSize"
        :manual="hoverVisible"
        v-if="!hidden && layout.indexOf('horizontal') > -1"></bar>
      <div class="shopee-scrollbar__content" :style="fixedStyle.content" ref="content">
        <slot></slot>
      </div>
    </div>
  </div>
</template>
<script>
import { addResizeListener, removeResizeListener } from 'shopee-ui/lib/base';
import { scrollAnimation } from './util';
import Bar from './bar.vue';

const scrollBarWidth = 20;
const minScrollThumbWidth = 24;

export default {
  name: 'ShopeeScrollbar',
  components: {
    Bar
  },
  props: {
    hidden: Boolean,
    layout: {
      type: String,
      default: 'vertical, horizontal',
      validator(value = 'vertical, horizontal') {
        return ['vertical', 'horizontal', 'vertical, horizontal'].indexOf(value) >= 0;
      }
    },
    manual: Boolean,
    hoverVisible: Boolean
  },
  data() {
    return {
      offsetX: 0,
      offsetY: 0,
      heightSize: 0,
      widthSize: 0,
      lastScrollTime: null,
      lastScrollTop: null,
      lastScrollLeft: null,
    };
  },
  computed: {
    fixedStyle() {
      let styles = {
        wrapper: {},
        content: {},
      };
      if (this.manual) {
        styles.wrapper.overflow = 'hidden';
      }
      if (this.heightSize !== 0) {
        styles.wrapper.marginRight = `-${scrollBarWidth}px`;
        styles.wrapper.paddingRight = `${scrollBarWidth}px`;
        // firefox paddingRight of scroll element is not work
        styles.content.marginRight = `-${scrollBarWidth}px`;
        styles.content.paddingRight = `${scrollBarWidth}px`;
      }
      if (this.widthSize !== 0) {
        styles.wrapper.marginBottom = `-${scrollBarWidth}px`;
        styles.wrapper.paddingBottom = `${scrollBarWidth}px`;
        // firefox paddingBottom of scroll element is not work
        styles.content.marginBottom = `-${scrollBarWidth}px`;
        styles.content.paddingBottom = `${scrollBarWidth}px`;
      }
      return styles;
    },
    wrapper() {
      return this.$refs.wrapper;
    },
    content() {
      return this.$refs.content;
    },
  },
  mounted() {
    this.$nextTick(this.update);
    if (!this.noresize) {
      addResizeListener(this.content, this.update);
    }
    if (this.hoverVisible) {
      document.addEventListener('mousemove', this.onMouseover);
    }
  },
  beforeDestroy() {
    this.$nextTick(this.update);
    if (!this.noresize) {
      removeResizeListener(this.content, this.update);
    }
    document.removeEventListener('mousemove', this.onMouseover);
  },
  methods: {
    onScroll(e) {
      const wrapper = this.wrapper;
      this.$emit('scroll', e, this.calScrollInfo(e));
      // set vertical scrollbar thumb offset
      if (this.heightSize !== 0) {
        let clientHeight = wrapper.clientHeight;
        let scrollHeight = wrapper.scrollHeight;
        if (this.widthSize !== 0) {
          clientHeight -= scrollBarWidth;
          scrollHeight -= scrollBarWidth;
        }
        if (scrollHeight !== clientHeight) {
          this.offsetY = wrapper.scrollTop * (clientHeight - this.heightSize) / (scrollHeight - clientHeight);
        } else {
          this.offsetY = 0;
        }
      }
      // set horizontal scrollbar thumb offset
      if (this.widthSize !== 0) {
        let clientWidth = wrapper.clientWidth;
        let scrollWidth = wrapper.scrollWidth;
        if (this.heightSize !== 0) {
          clientWidth -= scrollBarWidth;
          scrollWidth -= scrollBarWidth;
        }
        if (scrollWidth !== clientWidth) {
          this.offsetX = wrapper.scrollLeft * (clientWidth - this.widthSize) / (scrollWidth - clientWidth);
        } else {
          this.offsetX = 0;
        }
      }
    },
    calScrollInfo(event) {
      if (event) {
        const now = new Date().getTime();
        const x = event.target.scrollLeft;
        const y = event.target.scrollTop;
        let dt = now - this.lastScrollTime;
        if (!this.lastScrollTime || dt > 1000) {
          dt = 1000;
        }
        const dx = x - this.lastScrollLeft;
        const dy = y - this.lastScrollTop;
        this.lastScrollTime = now;
        this.lastScrollLeft = x;
        this.lastScrollTop = y;
        return {
          x,
          y,
          vx: Number((dx / dt).toFixed(2)),
          vy: Number((dy / dt).toFixed(2)),
        };
      }
    },
    update() {
      const wrapper = this.wrapper;
      if (!wrapper) {
        return;
      }
      const layout = this.layout;
      // set vertical scrollbar thumb size
      if (layout.indexOf('vertical') > -1) {
        let clientHeight = wrapper.clientHeight;
        let scrollHeight = wrapper.scrollHeight;
        if (this.heightSize !== 0) {
          clientHeight -= scrollBarWidth;
          scrollHeight -= scrollBarWidth;
        }
        let heightSize = scrollHeight ? clientHeight * clientHeight / scrollHeight : 0;
        if (heightSize <= minScrollThumbWidth) {
          heightSize = minScrollThumbWidth;
        }
        if (heightSize >= clientHeight) {
          heightSize = 0;
        }
        this.heightSize = heightSize;
      }

      // set horizontal scrollbar thumb size
      if (layout.indexOf('horizontal') > -1) {
        let clientWidth = wrapper.clientWidth;
        let scrollWidth = wrapper.scrollWidth;
        if (this.widthSize !== 0) {
          clientWidth -= scrollBarWidth;
          scrollWidth -= scrollBarWidth;
        }
        let widthSize = scrollWidth ? clientWidth * clientWidth / scrollWidth : 0;
        if (widthSize <= minScrollThumbWidth) {
          widthSize = minScrollThumbWidth;
        }
        if (widthSize >= clientWidth) {
          widthSize = 0;
        }
        this.widthSize = widthSize;
      }
    },
    scrollTo(scrollTop, duration = 200) {
      scrollAnimation(this.wrapper, scrollTop, duration);
    },
    onMouseover(e) {
      if (this.hoverVisible) {
        if (this.$refs.wrapper.contains(e.target)) {
          this.$refs.horizontalBar && this.$refs.horizontalBar.show();
          this.$refs.verticalBar && this.$refs.verticalBar.show();
        } else {
          this.$refs.horizontalBar && this.$refs.horizontalBar.hide();
          this.$refs.verticalBar && this.$refs.verticalBar.hide();
        }
      }
    }

  }
};
</script>
