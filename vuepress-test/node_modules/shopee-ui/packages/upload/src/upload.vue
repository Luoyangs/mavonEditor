<template>
  <div class="shopee-upload">
    <div
      :class="{
        'shopee-upload-wrapper': true,
        'shopee-upload-dragger': drag,
        'is-dragover': drag && dragover,
        'disabled': disabled
      }"
      @click="handleClick"
      @keydown.enter="handleClick"
      @paste="handlePaste"
      @drop.prevent="onDrop"
      @dragover.prevent="onDragover"
      @dragleave.prevent="dragover = false">
        <input class="shopee-upload__input" ref="input" v-bind="$attrs" type="file" :name="name" :accept="accept" :multiple="multiple" :webkitdirectory="webkitdirectory" @change="handleChange">
        <slot></slot>
    </div>
    <slot name="tip"></slot>
    <slot name="list" :file-list="fileList"></slot>
  </div>
</template>

<script>
import { noop } from 'shopee-ui/lib/base';
import ajax from './ajax';

const filesAcceptFilter = (files, accept) => files.filter(file => {
  const { type, name } = file;
  const extension = name.indexOf('.') > -1 ? `.${ name.split('.').pop() }` : '';
  const baseType = type.replace(/\/.*$/, '');
  return accept.split(',')
    .map(type => type.trim())
    .filter(Boolean)
    .some(acceptedType => {
      if (/^\..+$/.test(acceptedType)) {
        return extension === acceptedType;
      }
      if (/\/\*$/.test(acceptedType)) {
        return baseType === acceptedType.replace(/\/\*$/, '');
      }
      if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
        return type === acceptedType;
      }
      return false;
    });
});

export default {
  name: 'ShopeeUpload',
  props: {
    action: String,
    name: {
      type: String,
      default: 'file'
    },
    data: Object,
    headers: {
      type: Object,
      default() {
        return {};
      }
    },
    withCredentials: Boolean,
    multiple: Boolean,
    webkitdirectory: Boolean,
    limit: Number,
    accept: String,
    drag: Boolean,
    // kb
    maxSize: Number,
    autoUpload: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    paste: Boolean,
    beforeUpload: {
      type: Function,
      default: noop
    },
    onProgress: {
      type: Function,
      default: noop
    },
    onSuccess: {
      type: Function,
      default: noop
    },
    onError: {
      type: Function,
      default: noop
    },
    onExceededSize: {
      type: Function,
      default: noop
    },
    onExceededLimit: {
      type: Function,
      default: noop
    },
    onExceededAccept: {
      type: Function,
      default: noop
    },
    httpRequest: {
      type: Function,
      default: ajax
    }
  },
  data() {
    return {
      fileList: [],
      reqs: {},
      tempIndex: 1,
      dragover: false
    };
  },
  methods: {
    submit(rawFile) {
      if (rawFile) {
        const file = this.getFile(rawFile);
        if (file && (file.status === 'ready' || file.status === 'fail')) {
          this.upload(file.raw);
        }
      } else {
        this.fileList
          .filter(file => file.status === 'ready' || file.status === 'fail')
          .forEach(file => {
            this.upload(file.raw);
          });
      }
    },
    abort(rawFile) {
      const reqs = this.reqs;
      if (rawFile) {
        const file = this.getFile(rawFile);
        if (file && reqs[file.uid]) {
          reqs[file.uid].abort();
          delete reqs[file.uid];
        }
      } else {
        Object.keys(reqs).forEach(uid => {
          if (reqs[uid]) {
            reqs[uid].abort();
          }
          delete reqs[uid];
        });
      }
    },
    clearFiles() {
      this.fileList = [];
    },
    remove(rawFile) {
      if (rawFile) {
        const file = this.getFile(rawFile);
        this.abort(file);

        const index = this.fileList.indexOf(file);
        if (index >= 0) {
          this.fileList.splice(index, 1);
        }
      } else {
        this.abort();
        this.clearFiles();
      }
      this.$emit('file-change', this.fileList);
    },
    uploadFiles(files) {
      let postFiles = Array.prototype.slice.call(files);
      let isFilesCountOver = false;

      if (!this.multiple) {
        if (postFiles.length > 1) {
          isFilesCountOver = true;
        }
        postFiles = postFiles.slice(0, 1);
        this.fileList = [];
      } else {
        if (this.limit && postFiles.length > this.limit) {
          isFilesCountOver = true;
          postFiles = postFiles.slice(0, this.limit);
        }
      }

      if (isFilesCountOver) {
        if (this.onExceededLimit && typeof this.onExceededLimit === 'function') {
          if (this.onExceededLimit(files.length) === false) {
            return;
          }
        }
      }

      if (postFiles.length === 0) {
        return;
      }

      postFiles.forEach(file => {
        // check maxSize
        if (this.maxSize) {
          if (file.size > this.maxSize * 1024) {
            this.onExceededSize(file, this.fileList);
            return false;
          }
        }

        this.handleStart(file);

        if (this.autoUpload) {
          this.upload(file);
        }
      });
      this.$emit('file-change', this.fileList);
    },
    upload(file) {
      if (!this.beforeUpload) {
        return this.post(file);
      }

      const before = this.beforeUpload(file);
      if (before && before.then) {
        before.then(processedFile => {
          const fileType = Object.prototype.toString.call(processedFile);

          if (fileType === '[object File]' || fileType === '[object Blob]') {
            if (fileType === '[object Blob]') {
              processedFile = new File([processedFile], file.name, {
                type: file.type
              });
            }
            for (const p in file) {
              if (file.hasOwnProperty(p)) {
                processedFile[p] = file[p];
              }
            }
            this.post(processedFile);
          } else {
            this.post(file);
          }
        }, () => {
          // this.$emit('cancel', file);
        });
      } else if (before !== false) {
        this.post(file);
      } else {
        // this.$emit('cancel', file);
      }
    },
    post(file) {
      if (!this.action) {
        console.warn('[ShopeeUI warn][Upload]: action required when upload');
        return;
      }
      const { uid } = file;
      const options = {
        headers: this.headers,
        withCredentials: this.withCredentials,
        file: file,
        data: this.data,
        filename: this.name,
        action: this.action,
        onProgress: e => {
          this.handleProgress(e, file);
        },
        onSuccess: res => {
          this.handleSuccess(res, file);
          delete this.reqs[uid];
        },
        onError: err => {
          this.handleError(err, file);
          delete this.reqs[uid];
        }
      };
      const req = this.httpRequest(options);
      this.reqs[uid] = req;
      if (req && req.then) {
        req.then(options.onSuccess, options.onError);
      }
    },
    handleStart(file) {
      file.uid = Date.now() + this.tempIndex++;

      let _file = {
        uid: file.uid,
        status: 'ready',
        name: file.name,
        size: file.size,
        percentage: 0,
        raw: file
      };

      try {
        _file.url = URL.createObjectURL(file);
      } catch (e) {
        console.warn(`[ShopeeUI warn][Upload]: error in creation url of ${file.name}: ${e}`);
      }

      this.fileList.push(_file);
    },
    getFile(file) {
      const uid = file.uid ? file.uid : file;
      return this.fileList.find(item => uid === item.uid);
    },
    handleProgress(e, file) {
      const _file = this.getFile(file);
      if (_file) {
        _file.status = 'uploading';
        _file.percentage = e.percent || 0;

        this.onProgress(e, _file, this.fileList);
      }
    },
    handleSuccess(res, file) {
      const _file = this.getFile(file);
      if (_file) {
        _file.status = 'success';
        _file.response = res;

        this.onSuccess(res, _file, this.fileList);
      }
    },
    handleError(err, file) {
      const _file = this.getFile(file);
      const fileList = this.fileList;

      if (_file) {
        _file.status = 'fail';
        // fileList.splice(fileList.indexOf(_file), 1);

        this.onError(err, _file, fileList);
      }
    },
    handleChange(e) {
      let files = e.target.files;
      if (!files) {
        return;
      }
      if (this.webkitdirectory) {
        files = this.addRelativePathForFile(files);
      }
      this.uploadFiles(files);
      this.$refs.input.value = null;
    },
    handleClick() {
      if (!this.disabled) {
        this.$refs.input.click();
      }
    },
    handlePaste(e) {
      if (!this.disabled && this.paste) {
        this.uploadFiles(e.clipboardData.files);
      }
    },
    onDragover() {
      if (!this.disabled) {
        this.dragover = true;
      }
    },
    async onDrop(e) {
      if (!this.disabled) {
        this.dragover = false;
        const allFiles = await this.getDropFiles(e);
        let files = allFiles;
        if (this.accept) {
          files = filesAcceptFilter(allFiles, this.accept);
          const exceededFiles = allFiles.filter(file => files.indexOf(file) === -1);
          if (exceededFiles.length > 0 && this.onExceededAccept(exceededFiles) === false) {
            return;
          }
        }
        this.uploadFiles(files);
      }
    },
    getDropFiles(e) {
      if (this.webkitdirectory && e.dataTransfer.items) {
        const fileItems = Array.prototype.slice.call(e.dataTransfer.items);
        let entries = fileItems.map(item => item.webkitGetAsEntry());
        // filter directories
        entries = entries.filter(item => item.isDirectory);
        return Promise.all(entries.map(this.getDirectoryEntryAsPromise))
          .then(res => res.reduce((files, n) => files.concat(n), []));
      } else {
        return Array.prototype.slice.call(e.dataTransfer.files);
      }
    },
    getDirectoryEntryAsPromise(directoryEntry) {
      return new Promise((resolve) => {
        const directoryReader = directoryEntry.createReader();
        directoryReader.readEntries(entries => {
          resolve(Promise.all(entries.map(entry => {
            if (entry.isDirectory) {
              return this.getDirectoryEntryAsPromise(entry);
            } else {
              return this.getFileEntryAsPromise(entry);
            }
          })).then(res => res.reduce((files, file) => files.concat(file), []))
          );
        });
      });
    },
    getFileEntryAsPromise(entry) {
      return new Promise((resolve, reject) => {
        entry.file(file => {
          // set relativePath for file
          // because webkitRelativePath of file is empty when drag
          file.relativePath = entry.fullPath;
          resolve(file);
        }, (e) => {
          reject(e);
        });
      }
      );
    },
    addRelativePathForFile(files) {
      files = Array.prototype.slice.call(files);
      files.forEach(file => {
        // set relativePath for file
        // because webkitRelativePath of file is empty when drag
        if (file.webkitRelativePath) {
          file.relativePath = file.webkitRelativePath;
        }
      });
      return files;
    }
  }
};
</script>
