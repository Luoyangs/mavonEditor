<template>
  <div class="shopee-time-spinner">
    <shopee-icon class="shopee-time-spinner__icon up"
      :class="{
        'disabled': innerValue == spinners[0].text
      }"
      :svg="arrowUpIcon"
      @click.native="onClickUp"
    ></shopee-icon>
    <shopee-scrollbar hidden @scroll="onScroll" ref="scroller">
      <ul class="shopee-time-spinner__list">
        <li v-for="(spinner, index) in spinners" :key="index"
          :class="{
            'selected': !spinner.disabled && innerValue == spinner.text,
            'disabled': spinner.disabled
          }"
          @click="onChange(spinner)">{{spinner.text}}</li>
      </ul>
    </shopee-scrollbar>
    <shopee-icon class="shopee-time-spinner__icon down"
      :class="{
        'disabled': innerValue == spinners[spinners.length - 1].text
      }"
     :svg="arrowDownIcon"
     @click.native="onClickDown"
    ></shopee-icon>
  </div>
</template>

<script>
import { Icon as ShopeeIcon } from 'shopee-ui/lib/icon';
import { Scrollbar as ShopeeScrollbar } from 'shopee-ui/lib/scrollbar';
import { debounce } from 'shopee-ui/lib/base';
import arrowUpIcon from '@shopee-ui/icon/svg/arrow-up-s.svg';
import arrowDownIcon from '@shopee-ui/icon/svg/arrow-down-s.svg';

const CELL_HEIGHT = 32; // css height

export default {
  components: {
    ShopeeIcon,
    ShopeeScrollbar
  },
  props: {
    value: [Number, String],
    max: Number,
    disabledValues: Array,
    showDisabled: Boolean
  },
  data() {
    return {
      arrowUpIcon,
      arrowDownIcon,
      spinnerTimeout: null,
      innerValue: this.value
    };
  },
  computed: {
    spinners() {
      const spinners = [];
      for (let i = 0; i < this.max; i++) {
        const text = i < 10 ? `0${i}` : i;
        const disabled = this.disabledValues.indexOf(i) > -1;
        if (this.showDisabled || !disabled) {
          spinners.push({
            text,
            disabled
          });
        }
      }
      return spinners;
    },
    debounce() {
      return debounce(n => n(), 60);
    }
  },
  watch: {
    value(val) {
      this.innerValue = val;
    },
    innerValue(val) {
      this.scrollTo(val);
    },
    'spinners.length'() {
      this.$nextTick(() => {
        this.scrollTo(this.innerValue, false);
      });
    }
  },
  methods: {
    presetValue(value) {
      const validValues = this.spinners.map(spinner => Number(spinner.text));
      // preset to first valid value
      if (validValues.indexOf(value) === -1) {
        value = validValues[0];
        this.emit(value);
      }
      this.$nextTick(() => {
        this.scrollTo(value, false);
      });
    },
    scrollTo(value, animated = true) {
      this.debounce(() => {
        if (this.$refs.scroller) {
          this.$refs.scroller.scrollTo(this.valueToScrollTop(value), animated ? 200 : 0);
        }
      });
    },
    onScroll(e, data) {
      if (this.spinnerTimeout) {
        clearTimeout(this.spinnerTimeout);
      }
      if (!this.isScrollEnd(data)) {
        return;
      }
      this.spinnerTimeout = setTimeout(() => {
        const value = this.scrollTopToValue(e.target.scrollTop);
        if (value !== this.innerValue) {
          this.emit(value);
        }
      }, 50);
    },
    isScrollEnd(data) {
      const isTooSlow = Math.abs(data.vy) < 0.01;
      const isFast = Math.abs(data.vy) > 0.1;
      const isTop = data.y === 0;
      const isBottom = data.y === (this.spinners.length - 1) * CELL_HEIGHT;
      if (!isFast || !isTooSlow || isTop || isBottom) {
        return true;
      }
      return false;
    },
    onChange(spinner) {
      if (spinner.disabled) {
        return;
      }
      this.emit(spinner.text);
    },
    onClickUp() {
      const preSpinner = [].concat(this.spinners).reverse().find(n => Number(n.text) < this.innerValue);
      if (preSpinner) {
        this.emit(Number(preSpinner.text));
      }
    },
    onClickDown() {
      const nextSpinner = this.spinners.find(n => Number(n.text) > this.innerValue);
      if (nextSpinner) {
        this.emit(Number(nextSpinner.text));
      }
    },
    valueToScrollTop(value) {
      const index = this.spinners.findIndex(n => n.text == value);
      return Math.round(index) * CELL_HEIGHT;
    },
    scrollTopToValue(scrollTop) {
      let index = Math.round(scrollTop / CELL_HEIGHT);
      const max = this.spinners.length - 1;
      index = index < 0 ? 0 : index > max ? max : index;
      return Number(this.spinners[index].text);
    },
    emit(value) {
      this.$emit('input', Number(value));
    }
  }
};
</script>
