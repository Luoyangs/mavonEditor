<template>
  <div :class="[
      'shopee-slider',
      vertical && 'shopee-slider--vertical',
      markArray.length > 0 && 'shopee-slider--with-marks',
      dragging && 'dragging',
      disabled && 'disabled'
    ]"
    @click="handleClick">
    <div ref="rail" class="shopee-slider-rail"></div>
    <div class="shopee-slider-stops">
      <div class="shopee-slider-stop" v-for="(percent, index) in stops" :key="index" :style="getStyle(percent)"></div>
    </div>
    <div class="shopee-slider-rail unrange" :style="untrackBeforeStyle" v-if="range"></div>
    <div class="shopee-slider-track" :style="trackStyle"></div>
    <div class="shopee-slider-rail unrange" :style="untrackAfterStyle"></div>
    <div class="shopee-slider-marks">
      <div class="shopee-slider-mark" v-for="(mark, index) in markArray" :key="index" :style="getStyle(getPercent(mark.value))">
        <div class="shopee-slider-mark-dot" :class="{'active': isActiveMark(mark.value)}"></div>
        <Render :render="mark.label"></Render>
      </div>
    </div>
    <div ref="thumb" class="shopee-slider-thumb"
      v-for="(percent, index) in percentValues"
      :key="index"
      :style="getStyle(percent)"
      @mousedown.prevent="onDragStart($event, index)"
      @touchstart.prevent="onDragStart($event, index)"
      @mouseenter="onMouseenter(index)"
      @mouseleave="onMouseleave">
      <shopee-tooltip
        ref="tooltip"
        :value="tooltipOptions[index].value"
        :content="tooltipOptions[index].content"
        placement="top"
        :append-to-body="false"
        :popper-class="'shopee-slider-thumb__popper ' + (tipClass || '')">
        <div class="shopee-slider-thumb__button" :class="{'dragging': movingIndex === index}"></div>
      </shopee-tooltip>
    </div>
  </div>
</template>

<script>
import { Tooltip as ShopeeTooltip } from 'shopee-ui/lib/tooltip';
import { isFunction, isArray } from 'shopee-ui/lib/base';
import { addDecimalNumber } from 'shopee-ui/lib/base';
import { Render } from 'shopee-ui/lib/base';

export default {
  name: 'ShopeeSlider',
  components: {
    ShopeeTooltip,
    Render
  },
  props: {
    value: {
      type: [Number, Array],
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    marks: Object,
    step: {
      type: Number,
      default: 1
    },
    showStops: Boolean,
    range: Boolean,
    disabled: Boolean,
    vertical: Boolean,
    // hover, always, never
    showTip: {
      type: String,
      default: 'hover',
      validator(value = 'hover') {
        return ['hover', 'always', 'never'].indexOf(value) >= 0;
      }
    },
    tipFormatter: Function,
    tipClass: String
  },
  data() {
    return {
      dragging: false,
      movingIndex: null,
      hoverIndex: null,
      innerValues: []
    };
  },
  computed: {
    stops() {
      const stops = [];
      if (this.showStops && this.step > 0) {
        const total = this.max - this.min;
        const stepWidth = this.step / total * 100;
        let stopCount = Math.floor(total / this.step);
        for (let i = 1; i < stopCount; i++) {
          stops.push(i * stepWidth);
        }
      }
      return stops;
    },
    markArray() {
      const markArray = [];
      for (let value in this.marks) {
        value = Number(value);
        if (!isNaN(value) && value <= this.max && value >= this.min) {
          markArray.push({
            value,
            label: h => h('span', [this.marks[value]])
          });
        }
      }
      return markArray;
    },
    tooltipOptions() {
      return this.innerValues.map((value, index) => {
        const content = this.formatedTip(value);
        const visible =
          this.showTip !== 'never' &&
          (this.showTip === 'always' ||
            (content.length > 0 &&
              (index === this.movingIndex || index === this.hoverIndex)));
        return {
          value: visible,
          content
        };
      });
    },
    percentValues() {
      return this.innerValues.map(value => this.getPercent(value));
    },
    trackStyle() {
      const values = this.percentValues;
      if (this.range) {
        return {
          [this.vertical ? 'bottom' : 'left']: values[0] + '%',
          [this.vertical ? 'height' : 'width']: values[1] - values[0] + '%'
        };
      } else {
        return {
          [this.vertical ? 'height' : 'width']: values[0] + '%'
        };
      }
    },
    untrackBeforeStyle() {
      const values = this.percentValues;
      if (this.range) {
        return {
          [this.vertical ? 'bottom' : 'left']: 0,
          [this.vertical ? 'height' : 'width']: values[0] + '%'
        };
      } else {
        return {};
      }
    },
    untrackAfterStyle() {
      const values = this.percentValues;
      if (this.range) {
        return {
          [this.vertical ? 'bottom' : 'left']: values[1] + '%',
          [this.vertical ? 'height' : 'width']: 100 - values[1] + '%'
        };
      } else {
        return {
          [this.vertical ? 'bottom' : 'left']: values[0] + '%',
          [this.vertical ? 'height' : 'width']: 100 - values[0] + '%'
        };
      }
    }
  },
  watch: {
    value: {
      immediate: true,
      handler(value) {
        value = isArray(value) ? value : [value];
        value = value.slice(0, this.range ? 2 : 1);
        // format value
        value = value.map(n => this.formatValue(n));
        this.setValues(value);
      }
    },
    innerValues(val, oldVal) {
      if (val.some((item, index) => item !== oldVal[index])) {
        this.emit(val);

        // update tooltip
        this.tooltipOptions.forEach((item, index) => {
          if (item.value) {
            this.$refs.tooltip[index].$refs.popover.$refs.popper.updatePopper();
          }
        });
      }
    }
  },
  mounted() {
    if (this.markArray.length === 0 && !this.step) {
      console.warn('[ShopeeUI warn][Slider]: step should be greater than 0 when marks key is not in closed interval [min, max].');
      return;
    }
    if (this.range) {
      if (!isArray(this.value) || isNaN(this.value[0]) || isNaN(this.value[1])) {
        console.warn('[ShopeeUI warn][Slider]: value should be a number array of two when range is true.');
        return;
      }
    }
  },
  methods: {
    getPercent(value) {
      return Number((value - this.min) / (this.max - this.min) * 100).toFixed(2);
    },
    getStyle(value) {
      return {
        [this.vertical ? 'bottom' : 'left']: value + '%',
      };
    },
    isActiveMark(value) {
      if (this.range) {
        return value <= this.innerValues[1] && value >= this.innerValues[0];
      } else {
        return value <= this.innerValues[0];
      }
    },
    formatedTip(value) {
      if (isFunction(this.tipFormatter)) {
        value = this.tipFormatter(value);
        if (!value && value !== 0 && value !== '0') {
          return '';
        }
      }
      return '' + value;
    },
    getEventPosition(event) {
      const key = this.vertical ? 'clientY' : 'clientX';
      return event.type.indexOf('touch') > -1 ? event.touches[0][key] : event[key];
    },
    getPosition(element) {
      const rect = element.getBoundingClientRect();
      return rect[this.vertical ? 'bottom' : 'left'];
    },
    getMovedValue(movedLength) {
      const rect = this.$refs.rail.getBoundingClientRect();
      const totalLength = rect[this.vertical ? 'height' : 'width'];
      return (this.vertical ? -1 : 1) * (movedLength / totalLength) * (this.max - this.min);
    },
    getClosestValueAndIndex(values, targetValue) {
      let index = 0;
      for (let i = 0; i < values.length; i++) {
        if (Math.abs(values[i] - targetValue) <= Math.abs(values[index] - targetValue)) {
          index = i;
        }
      }
      return {
        index,
        value: values[index]
      };
    },
    onMouseenter(index) {
      this.hoverIndex = index;
    },
    onMouseleave() {
      this.hoverIndex = null;
    },
    handleClick(event) {
      if (this.disabled) {
        return;
      }

      const movedLength = this.getEventPosition(event) - this.getPosition(this.$refs.rail);
      const newValue = this.getMovedValue(movedLength) + this.min;
      const { value, index } = this.getClosestValueAndIndex(this.innerValues, newValue);

      this.updateValue(newValue, value, index);
    },
    onDragStart(event, index) {
      if (this.disabled) {
        return;
      }

      // record initial value
      this.movingIndex = index;
      this.startValue = this.innerValues[index];
      this.startPosition = this.getEventPosition(event);

      // addEventListener
      window.addEventListener('mousemove', this.onDragging);
      window.addEventListener('touchmove', this.onDragging);
      window.addEventListener('mouseup', this.onDragEnd);
      window.addEventListener('touchend', this.onDragEnd);
      window.addEventListener('contextmenu', this.onDragEnd);
    },
    onDragging(event) {
      this.dragging = true;
      this.handleDragEvent(event);
    },
    onDragEnd(event) {
      this.dragging = false;
      this.handleDragEvent(event);

      // reset recorded value
      this.movingIndex = null;
      this.startValue = null;
      this.startPosition = null;

      // removeEventListener
      window.removeEventListener('mousemove', this.onDragging);
      window.removeEventListener('touchmove', this.onDragging);
      window.removeEventListener('mouseup', this.onDragEnd);
      window.removeEventListener('touchend', this.onDragEnd);
      window.removeEventListener('contextmenu', this.onDragEnd);
    },
    handleDragEvent(event) {
      if (this.movingIndex === null) {
        return;
      }
      const movedLength = this.getEventPosition(event) - this.startPosition;
      const currentValue = this.getMovedValue(movedLength) + this.startValue;

      this.updateValue(currentValue, this.startValue, this.movingIndex);
    },
    updateValue(newValue, oldValue, updateIndex = 0) {
      let values = JSON.parse(JSON.stringify(this.innerValues));

      newValue = this.formatValue(newValue);
      values.splice(updateIndex, 1, newValue);

      // emit change
      if (!this.dragging) {
        if (newValue !== oldValue) {
          this.emit(values, 'change');
        }
      }
      this.setValues(values, updateIndex);
    },
    formatValue(value) {
      if (value < this.min) {
        value = this.min;
      } else if (value > this.max) {
        value = this.max;
      }

      let result = null;
      // set to closest stop value
      if (this.step > 0) {
        const decimal = (String(this.step).split('.')[1] || '').length;
        const stops = Math.round((value - this.min) / this.step);
        result = addDecimalNumber(this.min, (this.step * stops).toFixed(decimal));
      }
      // set to closest mark value
      let markValues = this.markArray.map(n => n.value);
      if (markValues.length > 0) {
        if (result !== null) {
          markValues = markValues.concat(result);
        }
        result = this.getClosestValueAndIndex(markValues, value).value;
      }

      return result;
    },
    setValues(values, index = null) {
      // handle the first value is greater than the second value
      if (this.range && values[0] > values[1]) {
        if (index === null) {
          values.reverse();
        } else {
          const val = values[index];
          for (let index = 0; index < values.length; index++) {
            values[index] = val;
          }
        }
      }
      this.innerValues = values;
    },
    emit(value, eventType = 'input') {
      if (!isArray(this.value)) {
        value = value[0];
      }
      this.$emit(eventType, value);
    }
  }
};
</script>
