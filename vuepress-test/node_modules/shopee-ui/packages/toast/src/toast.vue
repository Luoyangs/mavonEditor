<template>
  <transition name="toast-slide" @enter="handleEnter" @leave="handleLeave">
    <div
      v-show="visible"
      :class="[className, classNames]"
      @mouseenter="onMouseenter"
      @mouseleave="onMouseleave">
      <div :class="prefixClass + '-body'" :style="{'max-width': maxWidth + 'px', 'min-width': minWidth + 'px'}">
        <shopee-icon :class="iconClass" :svg="typeIcon" v-if="showTypeIcon"></shopee-icon>
        <div :class="prefixClass + '__content'" v-if="message">{{message}}</div>
        <slot></slot>
      </div>
    </div>
  </transition>
</template>
<script>
import { Icon as ShopeeIcon } from 'shopee-ui/lib/icon';
import approvedSIcon from '@shopee-ui/icon/svg/success-s.svg';
import roundCloseSIcon from '@shopee-ui/icon/svg/error-s.svg';
import warningIcon from '@shopee-ui/icon/svg/notice-circle-s.svg';
import messageIcon from '@shopee-ui/icon/svg/infomation-s.svg';

const TYPES = ['success', 'error', 'warning', 'message'];
const TYPES_ICON_MAP = {
  success: approvedSIcon,
  error: roundCloseSIcon,
  warning: warningIcon,
  message: messageIcon
};
export default {
  name: 'ShopeeToast',
  components: {
    ShopeeIcon
  },
  props: {
    // symbol in toasts
    sid: {},
    type: String,
    message: String,
    maxWidth: {
      type: Number,
      default: 600
    },
    minWidth: {
      type: Number,
      default: 160
    },
    duration: {
      type: Number,
      default: 3000
    },
    keepOnHover: Boolean,
    classNames: Array
  },
  data() {
    return {
      prefixClass: 'shopee-toast',
      visible: false,
      timeout: undefined
    };
  },
  computed: {
    className() {
      return [
        this.prefixClass,
        this.showTypeIcon ? 'has-icon' : ''
      ];
    },
    showTypeIcon() {
      return TYPES.indexOf(this.type) !== -1;
    },
    typeIcon() {
      return TYPES_ICON_MAP[this.type];
    },
    iconClass() {
      return [
        `${this.prefixClass}__icon`,
        this.showTypeIcon ? `${this.prefixClass}__icon--${this.type}` : ''
      ];
    }
  },
  mounted() {
    this.$parent && this.$parent.addInstance(this);
    this.timeout = setTimeout(() => {
      this.close();
    }, this.duration);
  },
  beforeDestroy() {
    this.$parent && this.$parent.remove(this.sid);
  },
  methods: {
    close() {
      this.$el.addEventListener('transitionend', this.destroy);
      this.$el.addEventListener('animationend', this.destroy);
      this.visible = false;
      this.$emit('close');
    },
    destroy() {
      this.$el.removeEventListener('transitionend', this.destroy);
      this.$el.removeEventListener('animationend', this.destroy);
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    handleEnter(el) {
      el.style.height = el.scrollHeight + 'px';
    },
    handleLeave(el) {
      if (el.parentNode && el.parentNode.children.length > 1) {
        el.style.height = 0;
        el.style.marginBottom = 0;
      }
    },
    onMouseenter() {
      if (this.keepOnHover) {
        if (this.timeout) {
          clearTimeout(this.timeout);
        }
      }
    },
    onMouseleave() {
      if (this.keepOnHover) {
        this.timeout = setTimeout(() => {
          this.close();
        }, this.duration);
      }
    }
  }
};
</script>
