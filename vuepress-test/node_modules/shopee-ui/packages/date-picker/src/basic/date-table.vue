<template>
  <div :class="prefixClass">
    <div :class="prefixClass + '__header'">
      <div :class="prefixClass + '__cell'" v-for="(header, index) in headers" :key="index">
        <span :class="prefixClass + '__cell-inner'">{{t(`shopee-ui.date-picker.weeks.${header}`)}}</span>
      </div>
    </div>
    <div :class="prefixClass + '__rows'" >
      <div :class="prefixClass + '__row'" v-for="(row, index) in calendar" :key="index">
        <div v-for="(cell, index) in row"
          :key="index"
          :class="[prefixClass + '__cell', getTableCellStyle(cell, row[index - 1], row[index + 1])]"
          @mouseenter="onMouseEnter(cell)"
          @mouseleave="onMouseLeaveTable"
          @click="onClick(cell)">
          <span
            :class="[prefixClass + '__cell-inner', getTableCellStyle(cell, row[index - 1], row[index + 1])]">
            <Render v-if="dateCellSlot" :as="dateCellSlot(cell)"></Render>
            <template v-else>{{cell.text}}</template>
          </span>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { LocaleMixin, Render } from 'shopee-ui/lib/base';
import * as Util from '../utils/util';

const getDateByCalendarCell = (cell, year, month) => {
  const cellType = cell.type;
  if (cellType === 'last-month') {
    const lastMonth = Util.lastMonth(year, month);
    return new Date(lastMonth.year, lastMonth.month, +cell.text);
  } else if (cellType === 'next-month') {
    const nextMonth = Util.nextMonth(year, month);
    return new Date(nextMonth.year, nextMonth.month, +cell.text);
  } else {
    return new Date(year, month, +cell.text);
  }
};

export default {
  name: 'ShopeeDateTable',
  components: {
    Render
  },
  mixins: [LocaleMixin],
  props: {
    year: {
      default() {
        return new Date().getFullYear();
      }
    },
    month: {
      default() {
        return new Date().getMonth();
      }
    },
    selection: Object,
    selectingRange: {
      type: Object,
      default() {
        return {};
      }
    },
    disabledDate: Function,
    min: {},
    max: {},
    showOverflowDate: Boolean,
    // start of week: 0 stands for Sunday and 6 stands for Saturday
    startOfWeek: {
      type: Number,
      default: 0,
      validator(val) {
        return val <= 6 && val >= 0;
      }
    }
  },
  data() {
    return {
      prefixClass: 'shopee-date-table',
      dateCellSlot: null
    };
  },
  computed: {
    headers() {
      const startOfWeek = this.startOfWeek;
      const headers = [];
      for (let i = 0; i < 7; i++) {
        headers.push(Util.WEEKS[(startOfWeek + i) % 7]);
      }
      return headers;
    },
    calendar() {
      const { year, month, startOfWeek } = this;
      const startDateOfCalendar = Util.getStartDateOfCalendar(year, month, startOfWeek).getDate();
      const maxDayOfMonth = Util.getMaxDayOfMonth(year, month);
      const dayOfLastMonth = ((Util.getFirstDayOfMonth(year, month) - startOfWeek + 7) % 7);
      const totalDayInCalendar = Math.ceil((maxDayOfMonth + dayOfLastMonth) / 7) * 7;
      const calendar = [];
      let row = [];
      for (let i = 0; i < totalDayInCalendar; i++) {
        let newCell = this.computeTableCellText(i, dayOfLastMonth, maxDayOfMonth, startDateOfCalendar);
        if (newCell.text !== '') {
          // set start and end tag
          if (i % 7 === 0) {
            newCell.isStart = true;
          }
          if (i % 7 === 6) {
            newCell.isEnd = true;
          }
          if (!this.showOverflowDate) {
            if (newCell.text === 1) {
              newCell.isStart = true;
            }
            if (newCell.text === maxDayOfMonth) {
              newCell.isEnd = true;
            }
          }

          // set month start and end tag
          if (newCell.text === 1) {
            newCell.isMonthStart = true;
          }
          if (newCell.text === maxDayOfMonth) {
            newCell.isMonthEnd = true;
          }

          // calculate current date
          let currentDate = new Date(year, month, +newCell.text);
          if (this.showOverflowDate) {
            currentDate = getDateByCalendarCell(newCell, year, month);
          }
          // set date
          newCell.date = currentDate;
          newCell = this.computeTableCellProps(newCell, currentDate);
        } else {
          newCell.date = null;
        }

        // push cell
        if (i % 7 === 0) {
          row = [];
        }
        row.push(newCell);
        if (i % 7 === 6) {
          calendar.push(row);
        }
      }
      return calendar;
    }
  },
  created() {
    this.$on('add-date-cell-slot', scopedSlot => {
      this.dateCellSlot = scopedSlot;
    });
  },
  methods: {
    computeTableCellText(index, dayOfLastMonth, maxDayOfMonth, startDateOfCalendar) {
      const startDayOfMonthDiff = index - dayOfLastMonth + 1;
      if (startDayOfMonthDiff <= 0) {
        return {
          text: this.showOverflowDate ? startDateOfCalendar + index : '',
          type: 'last-month'
        };
      } else if (startDayOfMonthDiff <= maxDayOfMonth) {
        const text = startDayOfMonthDiff;
        return {
          text,
          type: Util.isToday(new Date(this.year, this.month, text)) ? 'current' : 'normal'
        };
      } else {
        return {
          text: this.showOverflowDate ? startDayOfMonthDiff - maxDayOfMonth : '',
          type: 'next-month'
        };
      }
    },
    computeTableCellProps(cell, currentDate) {
      // out of min and max date
      if (this.min && Util.compareDate(this.min, currentDate) === 1) {
        cell.disabled = true;
      }
      if (this.max && Util.compareDate(currentDate, this.max) === 1) {
        cell.disabled = true;
      }
      // set disabled by calling disabledDate function
      if (this.disabledDate) {
        cell.disabled = this.disabledDate(currentDate);
      }
      // set selected and range status
      if ((cell.type === 'normal' || cell.type === 'current')) {
        const selection = this.selection;
        const selectingRange = this.selectingRange;
        if (selection.type === 'date') {
          // date picker
          if (Util.isSameDay(currentDate, selection.date)) {
            cell.selected = true;
          }
        } else {
          if (selection.type === 'week') {
            // week picker
            if (Util.isDateInRange(currentDate, selection.startDate, selection.endDate, true)) {
              cell.isWeekSelection = true;
            }
            if (selectingRange.active) {
              if (Util.isDateInRange(currentDate, selectingRange.startDate, selectingRange.endDate, true)) {
                cell.isWeekSelecting = true;
              }
            }
          } else if (selection.type === 'range') {
            // daterange picker
            if (selectingRange.active) {
              if (Util.isSameDays(currentDate, [selectingRange.startDate, selectingRange.endDate])) {
                cell.selected = true;
              }
            }
          }
          // week and daterange picker
          if (Util.isSameDays(currentDate, [selection.startDate, selection.endDate])) {
            cell.selected = true;
          }
          if (Util.isDateInRange(currentDate, selection.startDate, selection.endDate)) {
            cell.inRange = true;
          } else if (Util.isSameDay(currentDate, selection.startDate)) {
            cell.isRangeStart = true;
          } else if (Util.isSameDay(currentDate, selection.endDate)) {
            cell.isRangeEnd = true;
          }
          if (selectingRange.active) {
            const reselectingMode = selectingRange.isSelecting && !!selection.endDate;
            if (Util.isDateInRange(currentDate, selectingRange.startDate, selectingRange.endDate)) {
              if (reselectingMode) {
                cell.inSelectingRange = true;
              } else {
                cell.inRange = true;
              }
            } else if (Util.isSameDay(currentDate, selectingRange.startDate)) {
              if (reselectingMode) {
                cell.isSelectingRangeStart = true;
              } else {
                cell.isRangeStart = true;
              }
            } else if (Util.isSameDay(currentDate, selectingRange.endDate)) {
              if (reselectingMode) {
                cell.isSelectingRangeEnd = true;
              } else {
                cell.isRangeEnd = true;
              }
            }
          }
        }
      }
      return cell;
    },
    getTableCellStyle(cell, prevCell, nextCell) {
      return {
        'out-of-month': cell.type === 'last-month' || cell.type === 'next-month',
        'normal': cell.type === 'normal',
        'normal current': cell.type === 'current',
        'selected': cell.selected,
        'in-range': cell.inRange,
        'range-start': cell.isRangeStart,
        'range-end': cell.isRangeEnd,
        'in-selecting-range': cell.inSelectingRange,
        'selecting-range-start': cell.isSelectingRangeStart,
        'selecting-range-end': cell.isSelectingRangeEnd,
        'line-start': cell.isStart,
        'line-end': cell.isEnd,
        'is-empty': cell.text.length === 0,
        'month-start': cell.isMonthStart,
        'month-end': cell.isMonthEnd,
        'week-selection': cell.isWeekSelection,
        'week-selecting': !cell.isWeekSelection && cell.isWeekSelecting,
        'disabled': cell.disabled,
        'disabled-prev': !cell.disabled && nextCell && nextCell.disabled,
        'disabled-next': !cell.disabled && prevCell && prevCell.disabled,
      };
    },
    onMouseEnter(cell) {
      if (cell.text.length === 0 || cell.disabled) {
        return;
      }
      this.$emit('enter-table');

      let currentDate = new Date(this.year, this.month, +cell.text);
      if (this.showOverflowDate) {
        currentDate = getDateByCalendarCell(cell, this.year, this.month);
      }
      if (this.selection.type === 'week') {
        let week = Util.getWeekByDate(currentDate, this.startOfWeek);
        if (this.min) {
          week.startDate = this.min > week.startDate ? this.min : week.startDate;
        }
        if (this.max) {
          week.endDate = this.max < week.endDate ? this.max : week.endDate;
        }
        this.$emit('selecting-range-update', week);
      } else if (this.selectingRange.startDate && this.selectingRange.isSelecting) {
        this.$emit('selecting-range-update', {
          endDate: currentDate,
          startDate: this.selectingRange.startDate,
          isSelecting: true
        });
      }
    },
    onClick(cell) {
      if (cell.text.length === 0 || cell.disabled) {
        return;
      }
      let clickedDate = new Date(this.year, this.month, +cell.text);
      if (this.showOverflowDate) {
        clickedDate = getDateByCalendarCell(cell, this.year, this.month);
      }
      const selection = this.selection;
      let newSelection = null;
      if (selection.type === 'range') {
        const selectingRange = this.selectingRange;
        // start a new range
        if (!selectingRange.startDate || !this.selectingRange.isSelecting) {
          newSelection = {
            startDate: clickedDate,
            endDate: undefined,
            isSelecting: true
          };
        } else {
          // select the second date of range picker
          if (selectingRange.startDate.getTime() > clickedDate.getTime()) {
            newSelection = {
              startDate: clickedDate,
              endDate: selectingRange.startDate,
              isSelecting: false
            };
          } else {
            newSelection = {
              startDate: selectingRange.startDate,
              endDate: clickedDate,
              isSelecting: false
            };
          }
        }
        this.$emit('selecting-range-update', newSelection);
        this.$emit('input', {
          startDate: newSelection.startDate,
          endDate: newSelection.endDate
        });
      } else if (selection.type === 'week') {
        let week = Util.getWeekByDate(clickedDate, this.startOfWeek);
        if (this.min) {
          week.startDate = this.min > week.startDate ? this.min : week.startDate;
        }
        if (this.max) {
          week.endDate = this.max < week.endDate ? this.max : week.endDate;
        }
        this.$emit('selecting-range-update', {});
        this.$emit('input', week);
      } else {
        this.$emit('input', clickedDate);
      }
    },
    onMouseLeaveTable() {
      this.$emit('leave-table');
    }
  }
};
</script>
