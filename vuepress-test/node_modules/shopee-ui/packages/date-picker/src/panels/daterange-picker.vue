<template>
  <div :class="prefixClass">
    <div :class="[prefixClass + '__body']">
      <div :class="[prefixClass + '__body-left']">
        <div :class="[datePickerPrefixClass + '__time']" v-if="showTime">
          <shopee-time-picker-panel
            ref="startTimePickerPanel"
            v-model="left.time"
            v-bind="timePickerProps.start"
          ></shopee-time-picker-panel>
        </div>
        <div :class="[datePickerPrefixClass + '__date']">
          <shopee-picker-header
            :year="left.year"
            :month="left.month"
            :year-range="left.yearRange"
            :view="left.view"
            :hide-next-month="disabledNextMonth"
            :hide-next-year="disabledNextYear"
            @year-click="changeView('left', 'year')"
            @month-click="changeView('left', 'month')"
            @next="next('left', $event)"
            @prev="prev('left', $event)"></shopee-picker-header>
          <shopee-date-table
            v-if="type !== 'yearrange' && type !== 'monthrange'"
            v-show="left.view === 'date'"
            :selection="selection"
            :selecting-range="selectingRange"
            :year="left.year"
            :month="left.month"
            :min="currentMin"
            :max="currentMax"
            :disabled-date="disabledDate"
            :show-overflow-date="showOverflowDate"
            :start-of-week="startOfWeek"
            @input="onSelectionInput"
            @selecting-range-update="onSelectingRangeUpdate"
            @enter-table="onEnterTable"
            @leave-table="onLeaveTable"></shopee-date-table>
          <shopee-month-table
            v-if="type !== 'yearrange'"
            v-show="left.view === 'month'"
            :value="selection.startDate"
            :year="left.year"
            :min="minStartMonth"
            :max="maxStartMonth"
            @input="onStartMonthInput"></shopee-month-table>
          <shopee-year-table
            v-show="left.view === 'year'"
            :value="selection.startDate"
            :range="left.yearRange"
            :month="left.month"
            :min="minStartMonth"
            :max="maxStartMonth"
            @input="onStartYearInput"></shopee-year-table>
        </div>
      </div>
      <div :class="[prefixClass + '__body-right']">
        <div :class="[datePickerPrefixClass + '__date']">
          <shopee-picker-header
            :year="right.year"
            :month="right.month"
            :year-range="right.yearRange"
            :view="right.view"
            :hide-prev-month="disabledNextMonth"
            :hide-prev-year="disabledPrevYear"
            @year-click="changeView('right', 'year')"
            @month-click="changeView('right', 'month')"
            @next="next('right', $event)"
            @prev="prev('right', $event)"></shopee-picker-header>
          <shopee-date-table
            v-if="type !== 'yearrange' && type !== 'monthrange'"
            v-show="right.view === 'date'"
            :selection="selection"
            :selecting-range="selectingRange"
            :year="right.year"
            :month="right.month"
            :min="currentMin"
            :max="currentMax"
            :disabled-date="disabledDate"
            :show-overflow-date="showOverflowDate"
            :start-of-week="startOfWeek"
            @input="onSelectionInput"
            @selecting-range-update="onSelectingRangeUpdate"
            @enter-table="onEnterTable"
            @leave-table="onLeaveTable"></shopee-date-table>
          <shopee-month-table
            v-if="type !== 'yearrange'"
            v-show="right.view === 'month'"
            :value="selection.endDate"
            :year="right.year"
            :min="minEndMonth"
            :max="maxEndMonth"
            @input="onEndMonthInput"></shopee-month-table>
          <shopee-year-table
            v-show="right.view === 'year'"
            :value="selection.endDate"
            :range="right.yearRange"
            :month="right.month"
            :min="minEndMonth"
            :max="maxEndMonth"
            @input="onEndYearInput"></shopee-year-table>
        </div>
        <div :class="[datePickerPrefixClass + '__time']" v-if="showTime">
          <shopee-time-picker-panel
            ref="endTimePickerPanel"
            v-model="right.time"
            v-bind="timePickerProps.end"
          ></shopee-time-picker-panel>
        </div>
      </div>
    </div>
    <div :class="[prefixClass + '__footer']" v-if="showTime">
      <shopee-button type="primary" size="small" :disabled="disabledConfirm" @click="onConfirm">{{t('shopee-ui.date-picker.confirm')}}</shopee-button>
    </div>
  </div>
</template>

<script>
import { Button as ShopeeButton } from 'shopee-ui/lib/button';
import { TimePicker as ShopeeTimePicker } from 'shopee-ui/lib/time-picker';
import ShopeeDateTable from '../basic/date-table.vue';
import ShopeeMonthTable from '../basic/month-table.vue';
import ShopeeYearTable from '../basic/year-table.vue';
import ShopeePickerHeader from '../basic/picker-header.vue';
import { EventBusMixin, LocaleMixin } from 'shopee-ui/lib/base';
import * as Util from '../utils/util';

export default {
  name: 'ShopeeDaterangePickerPanel',
  components: {
    ShopeeDateTable,
    ShopeeMonthTable,
    ShopeeYearTable,
    ShopeeButton,
    ShopeePickerHeader,
    ShopeeTimePickerPanel: ShopeeTimePicker.panel
  },
  mixins: [EventBusMixin, LocaleMixin],
  props: {
    value: {
      type: Object,
      default() {
        return {};
      }
    },
    // `daterange`/`monthrange`/`yearrange`/`datetimerange`
    type: {
      type: String,
      default: 'daterange'
    },
    disabledDate: Function,
    min: [Date, Function],
    max: [Date, Function],
    showOverflowDate: Boolean,
    // start of week: 0 stands for Sunday and 6 stands for Saturday
    startOfWeek: {
      type: Number,
      default: 0,
      validator(val) {
        return val <= 6 && val >= 0;
      }
    },
    // false, start, end
    fixed: {
      type: [Boolean, String],
      default: false,
      validator(value = false) {
        return [false, 'start', 'end'].indexOf(value) >= 0;
      }
    },
    timePickerProps: Object
  },
  data() {
    const now = new Date();
    return {
      prefixClass: 'shopee-daterange-picker-panel',
      datePickerPrefixClass: 'shopee-date-picker-panel',
      left: {
        view: 'date',
        viewHistory: [],
        time: now,
        month: now.getMonth(),
        year: now.getFullYear(),
        yearRange: Util.getYearRange(now.getFullYear())
      },
      right: {
        view: 'date',
        viewHistory: [],
        time: now,
        month: now.getMonth(),
        year: now.getFullYear(),
        yearRange: Util.getYearRange(now.getFullYear())
      },
      selection: {
        type: 'range',
        startDate: undefined,
        endDate: undefined
      },
      selectingRange: {
        startDate: undefined,
        endDate: undefined,
        isSelecting: false,
        active: false
      },
      fixedStartDate: undefined,
      unwatch: null,
    };
  },
  computed: {
    currentMin() {
      return this.handleDateLimitFunc(this.min);
    },
    currentMax() {
      return this.handleDateLimitFunc(this.max);
    },
    minStartMonth() {
      const min = this.currentMin;
      if (min && Util.isValidDate(min)) {
        return {
          year: min.getFullYear(),
          month: min.getMonth()
        };
      }
    },
    maxStartMonth() {
      const lastRightMonth = Util.lastMonth(this.right.year, this.right.month);
      if (this.maxEndMonth) {
        return Util.compareMonth(this.maxEndMonth, lastRightMonth) >= 0 ? lastRightMonth : this.maxEndMonth;
      }
      return lastRightMonth;
    },
    minEndMonth() {
      const nextLeftMonth = Util.nextMonth(this.left.year, this.left.month);
      if (this.minStartMonth) {
        return Util.compareMonth(nextLeftMonth, this.minStartMonth) >= 0 ? nextLeftMonth : this.minStartMonth;
      }
      return nextLeftMonth;
    },
    maxEndMonth() {
      const max = this.currentMax;
      if (max && Util.isValidDate(max)) {
        return {
          year: max.getFullYear(),
          month: max.getMonth()
        };
      }
    },
    disabledNextYear() {
      if (this.left.view === 'year') {
        return Util.compareMonth({
          year: this.left.yearRange.end + 1,
          month: this.left.month
        }, this.right) !== -1;
      } else {
        return Util.compareMonth({
          year: this.left.year + 1,
          month: this.left.month
        }, this.right) !== -1;
      }
    },
    disabledPrevYear() {
      if (this.right.view === 'year') {
        return Util.compareMonth(this.left, {
          year: this.right.yearRange.start - 1,
          month: this.right.month
        }) !== -1;
      } else {
        return Util.compareMonth(this.left, {
          year: this.right.year - 1,
          month: this.right.month
        }) !== -1;
      }
    },
    disabledNextMonth() {
      const nextMonth = Util.nextMonth(this.left.year, this.left.month);
      return Util.compareMonth(nextMonth, this.right) !== -1;
    },
    disabledConfirm() {
      return !this.selection.startDate || !this.selection.endDate;
    },
    showTime() {
      if (this.type.indexOf('time') !== -1) {
        return true;
      } else {
        return false;
      }
    }
  },
  watch: {
    value() {
      this.resetView();
    },
    fixed: {
      immediate: true,
      handler(val) {
        if (val) {
          if (val === 'start' && this.value.startDate) {
            this.fixedStartDate = Util.getStartOfDate(this.value.startDate);
          } else if (val === 'end' && this.value.endDate) {
            this.fixedStartDate = Util.getStartOfDate(this.value.endDate);
          } else {
            console.warn('[ShopeeUI warn][DatePicker]: should initialize the fixed date in value when `fixed` is set other than false');
          }
        } else {
          this.fixedStartDate = undefined;
        }
      }
    }
  },
  mounted() {
    this.resetView();
    if (this.$scopedSlots.dateCell) {
      this.broadcast('ShopeeDateTable', 'add-date-cell-slot', this.$scopedSlots.dateCell);
    }
    const unwatchLeft = this.$watch(() => `${this.left.month + 1}/${this.left.year}`, (val) => {
      this.$emit('date-view-change', 'left', val);
    });
    const unwatchRight = this.$watch(() => `${this.right.month + 1}/${this.right.year}`, (val) => {
      this.$emit('date-view-change', 'right', val);
    });
    this.unwatch = [unwatchLeft, unwatchRight];
  },
  beforeDestroy() {
    if (this.unwatch) {
      this.unwatch.forEach(unwatch => {
        unwatch();
      });
    }
  },
  methods: {
    prev(section, type) {
      switch (this[section].view) {
        case 'month': {
          this[section].year = --this[section].year;
          break;
        }
        case 'year': {
          const { start, end } = this[section].yearRange;
          this[section].yearRange = {
            start: start - 10,
            end: end - 10
          };
          break;
        }
        case 'date': {
          if (type === 'month') {
            const lastMonth = Util.lastMonth(this[section].year, this[section].month);
            this[section].month = lastMonth.month;
            this[section].year = lastMonth.year;
          } else {
            this[section].year = --this[section].year;
          }
          break;
        }
      }
    },
    next(section, type) {
      switch (this[section].view) {
        case 'month': {
          this[section].year = ++this[section].year;
          break;
        }
        case 'year': {
          const { start, end } = this[section].yearRange;
          this[section].yearRange = {
            start: start + 10,
            end: end + 10
          };
          break;
        }
        case 'date': {
          if (type === 'month') {
            const nextMonth = Util.nextMonth(this[section].year, this[section].month);
            this[section].month = nextMonth.month;
            this[section].year = nextMonth.year;
          } else {
            this[section].year = ++this[section].year;
          }
          break;
        }
      }
    },
    resetView() {
      const val = this.value || {};

      let startDate = this.selection.startDate =
        Util.isValidDate(val.startDate) ?
          this.showTime ? val.startDate : Util.getStartOfDate(val.startDate) :
          undefined;
      let endDate = this.selection.endDate =
        Util.isValidDate(val.endDate) ?
          this.showTime ? val.endDate : Util.getEndOfDate(val.endDate) :
          undefined;

      // adjust date
      if (startDate && endDate) {
        if (startDate.getTime() > endDate.getTime()) {
          const temp = startDate;
          startDate = endDate;
          endDate = temp;
        }
      }
      // init selectingRange
      this.resetSelectingRange();
      // init year and month of left and right calendar
      let leftYear = (startDate || new Date()).getFullYear();
      let leftMonth = (startDate || new Date()).getMonth();
      let rightYear = (endDate || new Date()).getFullYear();
      let rightMonth = (endDate || new Date()).getMonth();
      // adjust year and month of right calendar
      if (leftYear === rightYear && leftMonth === rightMonth) {
        const nextMonth = Util.nextMonth(leftYear, leftMonth);
        rightYear = nextMonth.year;
        rightMonth = nextMonth.month;
      }
      // init year ranges
      const leftYearRange = Util.getYearRange(leftYear);
      const rightYearRange = Util.getYearRange(rightYear);
      // init left calendar and right calendar
      this.left.year = leftYear;
      this.left.month = leftMonth;
      this.left.yearRange = leftYearRange;
      this.right.year = rightYear;
      this.right.month = rightMonth;
      this.right.yearRange = rightYearRange;
      // init time of left and right calendar
      if (this.showTime) {
        this.left.time = startDate || new Date();
        this.right.time = endDate || new Date();
        // for type update, timeSpinner can access next tick
        this.$nextTick(() => {
          if (this.$refs.startTimePickerPanel) {
            this.$refs.startTimePickerPanel.resetView();
          }
          if (this.$refs.endTimePickerPanel) {
            this.$refs.endTimePickerPanel.resetView();
          }
        });
      }

      const type = this.type;
      this.left.view = (type === 'month' || type === 'year') ? type : 'date';
      this.right.view = (type === 'month' || type === 'year') ? type : 'date';
    },
    resetSelectingRange() {
      if (this.fixed && this.fixedStartDate) {
        this.selectingRange = {
          startDate: this.fixedStartDate,
          endDate: undefined,
          isSelecting: true
        };
      } else {
        this.selectingRange = {
          startDate: undefined,
          endDate: undefined,
          isSelecting: false
        };
      }
    },
    onSelectionInput(selection) {
      this.selection = {
        type: 'range',
        startDate: selection.startDate,
        endDate: selection.endDate
      };
      this.$emit('range-input', selection);
      if (selection.endDate) {
        this.resetSelectingRange();
      }
      if (!this.showTime) {
        if (selection.startDate && selection.endDate) {
          selection.endDate = Util.getEndOfDate(selection.endDate);
          this.emit({
            startDate: selection.startDate,
            endDate: selection.endDate
          });
        }
      }
    },
    onSelectingRangeUpdate(selectingRange) {
      this.selectingRange = {
        ...selectingRange,
        active: true,
        isSelecting: !!this.fixed || selectingRange.isSelecting
      };
    },
    onEnterTable() {
      if (this.selectingRange.startDate || this.selectingRange.endDate) {
        this.selectingRange = {
          ...this.selectingRange,
          active: true
        };
      }
    },
    onLeaveTable() {
      this.selectingRange = {
        ...this.selectingRange,
        endDate: undefined,
        active: false
      };
    },
    onStartYearInput(year) {
      this.left.year = year;
      this.changeView('left');
    },
    onStartMonthInput(month) {
      this.left.month = month;
      this.changeView('left');
    },
    onEndYearInput(year) {
      this.right.year = year;
      this.changeView('right');
    },
    onEndMonthInput(month) {
      this.right.month = month;
      this.changeView('right');
    },
    handleDateLimitFunc(limitFunc) {
      return typeof limitFunc === 'function' ? limitFunc(this.selectingRange, this.section) : limitFunc;
    },
    changeView(section, view) {
      if (view) {
        this[section].viewHistory.push(this[section].view);
        this[section].view = view;
      } else {
        const lastView = this[section].viewHistory.pop();
        this[section].view = lastView;
      }
    },
    onConfirm() {
      this.selection.startDate.setHours(this.left.time.getHours());
      this.selection.startDate.setMinutes(this.left.time.getMinutes());
      this.selection.startDate.setSeconds(this.left.time.getSeconds());
      this.selection.endDate.setHours(this.right.time.getHours());
      this.selection.endDate.setMinutes(this.right.time.getMinutes());
      this.selection.endDate.setSeconds(this.right.time.getSeconds());
      let range = {
        startDate: this.selection.startDate,
        endDate: this.selection.endDate
      };
      // rearrange selection
      if (this.selection.startDate.getTime() > this.selection.endDate.getTime()) {
        range = {
          startDate: this.selection.endDate,
          endDate: this.selection.startDate
        };
      }
      this.emit(range);
    },
    emit(selection) {
      this.$emit('input', selection);
      const {startDate, endDate} = this.value;
      if (
        !(
          startDate &&
          endDate &&
          startDate.getTime() === selection.startDate.getTime() &&
          endDate.getTime() === selection.endDate.getTime()
        )
      ) {
        this.$emit('change', selection);
      }
    }
  }
};
</script>
