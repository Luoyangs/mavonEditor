<template>
  <div class="shopee-table" :class="[{
      ['shopee-table-scrollX-' + scrollXState]: scrollXState,
      'shopee-table-scrollY': scrollYState || stickyState,
      'shopee-table--no-header': !showHeader,
      'shopee-table--border': border || isGroupingHeader,
      'shopee-table--striped': stripe,
      'shopee-table--empty-data': displayData.length === 0,
      'shopee-table--with-append': !!$slots.append,
    }]"
    :style="{'max-height': this.height + 'px'}">
    <div class="hidden-columns" ref="hiddenColumns"><slot></slot></div>
    <div class="shopee-table__header-container" v-if="showHeader" v-shopee-sticky="stickyOption">
      <div class="shopee-table__fix-header shopee-table__fix-left" v-if="leftFixedColumns.length > 0">
        <table-header :columns="leftFixedColumns"></table-header>
      </div>
      <div class="shopee-table__main-header" ref="header" v-shopee-mousewheel="handleHorizontalMousewheel">
        <table-header :columns="mainBodyColumns"></table-header>
      </div>
      <div class="shopee-table__fix-header shopee-table__fix-right" v-if="rightFixedColumns.length > 0">
        <table-header :columns="rightFixedColumns"></table-header>
      </div>
    </div>
    <div class="shopee-table__body-container" ref="bodyWrapper" v-shopee-mousewheel="handleMousewheel">
      <div class="shopee-table__fix-body shopee-table__fix-left" ref="leftBody" key="leftBody" v-if="leftFixedColumns.length > 0">
        <table-body :columns="leftBaseColumns" :data="displayData"></table-body>
      </div>
      <div class="shopee-table__main-body" ref="mainBody" key="mainBody">
        <shopee-scrollbar ref="scrollbar" hover-visible manual @scroll="onMainBodyScroll">
          <table-body :columns="mainBaseColumns" :data="displayData"></table-body>
          <div class="shopee-table__empty" v-show="!loading && displayData.length === 0">
            <slot name="empty">
              <div class="shopee-table__empty-content">
                <shopee-icon :svg="noDataIcon"></shopee-icon>
                <span class="shopee-table__empty-text">{{emptyText || t('shopee-ui.table.empty')}}</span>
              </div>
            </slot>
          </div>
          <div class="shopee-table__loading" v-show="loading">
            <slot name="loading"></slot>
          </div>
        </shopee-scrollbar>
      </div>
      <div class="shopee-table__fix-body shopee-table__fix-right" ref="rightBody" key="rightBody" v-if="rightFixedColumns.length > 0">
        <table-body :columns="rightBaseColumns" :data="displayData"></table-body>
      </div>
    </div>
    <div class="shopee-table__append" v-if="this.$slots.append" v-show="displayData.length > 0"><slot name="append"></slot></div>
  </div>
</template>
<script>
// TODO:
// min-width
// sort-remote
import { Icon as ShopeeIcon } from 'shopee-ui/lib/icon';
import { Popover as ShopeePopover } from 'shopee-ui/lib/popover';
import { Checkbox as ShopeeCheckbox } from 'shopee-ui/lib/checkbox';
import { Scrollbar as ShopeeScrollbar } from 'shopee-ui/lib/scrollbar';
import TableBody from './table-body';
import TableHeader from './table-header';
import { LocaleMixin, EventBusMixin } from 'shopee-ui/lib/base';
import { ShopeeMousewheel, ShopeeSticky } from 'shopee-ui/lib/base';
import { addResizeListener, removeResizeListener } from 'shopee-ui/lib/base';
import { getScrollParent, setStyles } from 'shopee-ui/lib/base';
import { debounce, isArray, mergeDeep } from 'shopee-ui/lib/base';
import noDataIcon from '@shopee-ui/icon/svg/no-data.svg';

const DEFAULT_COLUMN_WIDTH = 80;

export default {
  name: 'ShopeeTable',
  components: {
    TableBody,
    TableHeader,
    ShopeeIcon,
    ShopeePopover,
    ShopeeCheckbox,
    ShopeeScrollbar
  },
  directives: {ShopeeMousewheel, ShopeeSticky},
  mixins: [LocaleMixin, EventBusMixin],
  props: {
    data: Array,
    height: Number,
    border: Boolean,
    stripe: Boolean,
    valign: {
      type: String,
      default: 'top',
      validator(value = 'top') {
        return ['top', 'middle', 'bottom', 'baseline'].indexOf(value) >= 0;
      }
    },
    stickyHeader: Boolean,
    stickyOffset: {
      type: [Number, Object],
      default: 0
    },
    selectedRows: {
      type: Array,
      default() {
        return [];
      }
    },
    selectionStatusMethod: Function,
    rowDisabled: Function,
    scrollBarSticky: Boolean,
    showHeader: {
      type: Boolean,
      default: true
    },
    rowKey: [Function, String],
    rowClassName: [Function, String],
    emptyText: String,
    loading: Boolean,
    reverseSort: Boolean
  },
  data() {
    return {
      noDataIcon,
      columns: [],
      scrollXState: '',
      scrollYState: '',
      stickyState: '',
      headHeights: {},
      rowHeights: {},
      hoveredRow: null,
      stickyBarScrollParentEl: null,
      sortMethod: null,
      filters: [],
      expandRows: {}
    };
  },
  computed: {
    filterMethods() {
      return this.filters.map(({value, column}) =>
        row => {
          return value === undefined ||
            typeof column.filterMethod !== 'function' ||
            column.filterMethod(value, {row, column});
        }
      );
    },
    displayData() {
      let data = Array.prototype.slice.call(this.data);
      if (this.filterMethods && this.filterMethods.length > 0) {
        data = this.filterMethods.reduce((row, func) => row.filter(func), data);
      }
      if (this.sortMethod) {
        data = data.sort(this.sortMethod);
      }
      return data;
    },
    leftFixedColumns() {
      return this.columns.filter(column => column.level === 1 && column.fixed === 'left');
    },
    mainBodyColumns() {
      return this.columns.filter(column => column.level === 1 && column.fixed === '');
    },
    rightFixedColumns() {
      return this.columns.filter(column => column.level === 1 && column.fixed === 'right');
    },
    leftBaseColumns() {
      return this.getBaseColumns(this.leftFixedColumns);
    },
    mainBaseColumns() {
      return this.getBaseColumns(this.mainBodyColumns);
    },
    rightBaseColumns() {
      return this.getBaseColumns(this.rightFixedColumns);
    },
    baseColumns() {
      return this.leftBaseColumns.concat(this.mainBaseColumns, this.rightBaseColumns);
    },
    expandColumn() {
      return this.columns.find(column => column.type && column.type.indexOf('expand') > -1);
    },
    selectionStatus() {
      if (this.selectionStatusMethod) {
        return this.selectionStatusMethod(this.selectedRows, this.data.slice());
      }
      if (this.selectedRows.length === 0) {
        return 'empty';
      } else {
        if (this.selectedRows.length === this.data.length) {
          return 'all';
        } else {
          return 'part';
        }
      }
    },
    maxLevel() {
      return Math.max(...this.columns.map(n => n.level));
    },
    isGroupingHeader() {
      return this.maxLevel > 1;
    },
    stickyOption() {
      if (this.stickyHeader) {
        return {
          lazy: true,
          offset: this.stickyOffset,
          style: {
            zIndex: 2
          },
          onStateChange: this.handleStickyState
        };
      }
      return false;
    },
    layout() {
      return debounce(this.layoutHandler, 8);
    }
  },
  watch: {
    columns() {
      this.setBaseIndex(this.baseColumns);
      this.layout();
    },
    data() {
      this.layout();
    }
  },
  created() {
    this.$on('add-column', column => {
      if (this.columns.find(item => item.id === column.id)) {
        return;
      }
      if (column.type && this.columns.find(item => item.type === column.type)) {
        console.warn(`[ShopeeUI warn][Table]: The table column of type ${column.type} has been registered with more than one`);
        return;
      }
      this.columns = this.sortColumnsOrder([...this.columns, column]);
    });
    this.$on('remove-column', column => {
      const columns = this.columns.filter(item => item.id !== column.id);
      this.columns = this.sortColumnsOrder(columns);
    });
    this.$on('row-selection-change', (checked, rowValue) => {
      const selectedRows = this.selectedRows;
      const index = selectedRows.indexOf(rowValue);
      if (checked) {
        if (index === -1) {
          this.$emit('selection-change', selectedRows.concat([rowValue]));
        }
      } else {
        if (index !== -1) {
          this.$emit('selection-change', selectedRows.slice(0, index).concat(selectedRows.slice(index + 1, selectedRows.length)));
        }
      }
    });
    this.$on('seleced-all-change', (checked, prop) => {
      if (checked) {
        this.$emit('selection-change', this.data.map(row => row[prop]));
      } else {
        this.$emit('selection-change', []);
      }
    });
    this.$on('row-expand-change', (row, prop) => {
      const rowValue = row[prop];
      this.$set(this.expandRows, rowValue, !this.getExpandRow(row, prop));
    });
    this.$on('row-hover', rowIndex => {
      this.hoveredRow = rowIndex;
    });
    this.$on('sort', this.sort);
    this.$on('filters-change', this.filter);
    this.$on('layout', this.layout);
  },
  mounted() {
    addResizeListener(this.$el, this.layout);
    this.resetVerticalBar();
    document.addEventListener('mousemove', this.onMouseover);
    // add scroll event for sticky scrollBar
    if (this.scrollBarSticky) {
      const scrollEl = getScrollParent(this.$el);
      this.stickyBarScrollParentEl = scrollEl;
      scrollEl.addEventListener('scroll', this.handleScrollForStickyBar);
      window.addEventListener('resize', this.handleScrollForStickyBar);
      setTimeout(() => this.handleScrollForStickyBar(), 100);
    }
  },
  beforeDestroy() {
    removeResizeListener(this.$el, this.layout);
    // remove scroll event for sticky scrollBar
    if (this.stickyBarScrollParentEl) {
      const scrollEl = this.stickyBarScrollParentEl;
      scrollEl.removeEventListener('scroll', this.handleScrollForStickyBar);
      window.removeEventListener('resize', this.handleScrollForStickyBar);
    }
    document.removeEventListener('mousemove', this.onMouseover);
  },
  methods: {
    getBaseColumns(columns) {
      return columns.reduce((arr, column) => {
        if (column.children && column.children.length > 0) {
          arr.push(...this.getBaseColumns(column.children));
        } else {
          arr.push(column);
        }
        return arr;
      }, []);
    },
    layoutHandler() {
      const baseColumns = this.baseColumns;
      this.flexColumnWidth(baseColumns);
      this.$nextTick(() => {
        this.setScrollXState();
        this.setScrollYState();
        if (baseColumns.length > this.mainBaseColumns.length) {
          this.headHeights = this.getHeadHeights();
          this.rowHeights = this.getRowHeights();
        }
      });
    },
    flexColumnWidth(columns) {
      const fixedColumns = columns.filter(column => typeof column.width === 'number');
      const flexColumns = columns.filter(column => typeof column.width !== 'number');
      const fixedColumnsWidth = fixedColumns.reduce((accumulator, column) => accumulator + column.width, 0);
      if (flexColumns.length > 0) {
        const remainWidth = this.$el.clientWidth - fixedColumnsWidth;
        let widthOfFlexColumn = Math.floor(remainWidth / flexColumns.length);
        if (widthOfFlexColumn < DEFAULT_COLUMN_WIDTH) {
          widthOfFlexColumn = DEFAULT_COLUMN_WIDTH;
        }
        let widthOfLastFlexColumn = widthOfFlexColumn;
        const settedFlexWidth = widthOfFlexColumn * (flexColumns.length - 1);
        if (settedFlexWidth < remainWidth && remainWidth - settedFlexWidth > DEFAULT_COLUMN_WIDTH) {
          widthOfLastFlexColumn = remainWidth - settedFlexWidth;
        }
        flexColumns.forEach((column, index) => {
          column.realWidth = index === flexColumns.length - 1 ? widthOfLastFlexColumn : widthOfFlexColumn;
        });
      }
    },
    setBaseIndex(columns) {
      columns.forEach((column, index) => {
        column.index = index;
        column.isFirst = index === 0;
        column.isLast = index === columns.length - 1;
      });
    },
    getHeadHeights() {
      const heights = {};
      for (let index = 0; index < this.maxLevel; index++) {
        const cells = this.$el.querySelectorAll(`table thead tr:nth-child(${index + 1}) .shopee-table__cell`);
        cells.forEach(n => {
          const cellHeight = n.getBoundingClientRect().height;
          heights[index] = Math.max(heights[index] || 0, Math.ceil(cellHeight));
        });
      }
      return heights;
    },
    getRowHeights() {
      const heights = {};
      const hasBorder = this.border || this.isGroupingHeader;
      const expandColumn = this.expandColumn;
      const rowIndexs = this.data.reduce((accumulator, row, index) => {
        if (expandColumn) {
          const prop = expandColumn.rowKey || expandColumn.prop || 'id';
          const value = row[prop];
          if (this.expandRows[value]) {
            if (expandColumn.type === 'expand-tree') {
              const childProp = expandColumn.expandTreeChildProp;
              if (row[childProp]) {
                return accumulator.concat(index, row[childProp].map((_, childIndex) => `${index}-${childIndex}`));
              }
            } else if (expandColumn.type === 'expand') {
              return accumulator.concat(index, `${index}-${0}`);
            }
          }
        }
        return accumulator.concat(index);
      }, []);
      for (let i = 0; i < rowIndexs.length; i++) {
        const rowIndex = rowIndexs[i];
        const cells = this.$el.querySelectorAll(`table tbody tr:nth-child(${i + 1}) .shopee-table__cell`);
        cells.forEach(n => {
          const cellHeight = n.getBoundingClientRect().height;
          heights[rowIndex] = Math.max(heights[rowIndex] || 0, Math.ceil(cellHeight) + (hasBorder ? 1 : 0));
        });
      }
      return heights;
    },
    getExpandRow(row, prop) {
      const rowValue = row[prop];
      return this.expandRows[rowValue] || this.getDefaultExpandRow(row, prop);
    },
    getDefaultExpandRow(row, prop) {
      const expandColumn = this.expandColumn;
      const value = row[prop];
      if (expandColumn) {
        const defaultExpandRows = expandColumn.defaultExpandRows;
        if (typeof defaultExpandRows === 'string') {
          return defaultExpandRows === 'all';
        } else if (typeof defaultExpandRows === 'function') {
          return defaultExpandRows(mergeDeep(value), mergeDeep({row}));
        } else if (isArray(defaultExpandRows)) {
          return defaultExpandRows.indexOf(value) > -1;
        }
      }
      return false;
    },
    handleHorizontalMousewheel(event, data) {
      const { pixelX, pixelY } = data;
      if (Math.abs(pixelX) >= Math.abs(pixelY)) {
        const body = this.$refs.scrollbar.$refs.wrapper;
        if (body) {
          if (
            (pixelX < 0 && body.scrollLeft > 0) ||
            (pixelX > 0 && body.scrollWidth - body.clientWidth > body.scrollLeft)
          ) {
            event.preventDefault();
          }
          body.scrollLeft += pixelX;
        }
      }
    },
    handleMousewheel(event, data) {
      const { pixelX, pixelY } = data;
      if (Math.abs(pixelY) > Math.abs(pixelX)) {
        const body = this.$refs.scrollbar.$refs.wrapper;
        if (body) {
          if (
            (pixelY < 0 && body.scrollTop > 0) ||
            (pixelY > 0 && body.scrollHeight - body.clientHeight > body.scrollTop)
          ) {
            event.preventDefault();
          }
          body.scrollTop += pixelY;
        }
      } else if (this.$refs.mainBody.contains(event.target)) {
        this.handleHorizontalMousewheel(event, data);
      }
    },
    onMainBodyScroll(event) {
      const scrollLeft = event.target.scrollLeft;
      const scrollTop = event.target.scrollTop;
      this.$refs.header && (this.$refs.header.scrollLeft = scrollLeft);
      this.$refs.leftBody && (this.$refs.leftBody.scrollTop = scrollTop);
      this.$refs.rightBody && (this.$refs.rightBody.scrollTop = scrollTop);
      this.setScrollXState();
      this.setScrollYState();
    },
    setScrollXState() {
      if (this.$refs.scrollbar) {
        const body = this.$refs.scrollbar.$refs.wrapper;
        if (body.scrollWidth <= body.offsetWidth) {
          this.scrollXState = '';
        } else if (body.scrollLeft === body.scrollWidth - body.offsetWidth) {
          this.scrollXState = 'right';
        } else if (body.scrollLeft === 0) {
          this.scrollXState = 'left';
        } else {
          this.scrollXState = 'middle';
        }
      }
    },
    setScrollYState() {
      if (this.$refs.scrollbar) {
        const body = this.$refs.scrollbar.$refs.wrapper;
        if (body.scrollHeight > body.offsetHeight && body.scrollTop > 0) {
          this.scrollYState = 'on';
        } else {
          this.scrollYState = '';
        }
      }
    },
    resetVerticalBar() {
      if (this.$refs.scrollbar) {
        this.$refs.bodyWrapper.appendChild(this.$refs.scrollbar.$refs.verticalBar.$el);
      }
    },
    onMouseover(e) {
      if (this.$refs.scrollbar) {
        const body = this.$refs.bodyWrapper;
        const header = this.$refs.header;
        if (body && body.contains(e.target)) {
          this.$refs.scrollbar.$refs.verticalBar.show();
        }
        if (header && header.contains(e.target)) {
          this.$refs.scrollbar.$refs.horizontalBar.show();
        }
      }
    },
    clearSort() {
      if (this.sortMethod) {
        this.sortMethod = null;
      }
      this.broadcast('ShopeeTableHeader', 'clear-sort');
    },
    sort({column, type}) {
      this.broadcast('ShopeeTableHeader', 'sort-change', column);
      if (column.sortable === 'custom') {
        this.$emit('sort-change', {column, type});
        this.sortMethod = null;
      } else {
        if (column.sortMethod && typeof column.sortMethod === 'function') {
          this.sortMethod = (one, two) => {
            if (type === 'desc') {
              return column.sortMethod(one, two);
            } else if (type === 'asc') {
              return -1 * column.sortMethod(one, two);
            } else {
              return 0;
            }
          };
        }
      }
    },
    filter(filters) {
      let oldFilters = this.filters;
      oldFilters = oldFilters.filter(oldFilter => {
        return !filters.find(filter => filter.id === oldFilter.id);
      });
      this.filters = oldFilters.concat(filters);
      this.$emit('filter', this.filters);
    },
    handleStickyState(state) {
      if (state) {
        const stateArr = ['default', 'sticky', 'stuck'];
        this.stickyState = state === 'sticky' ? 'on' : '';
        this.$emit('sticky-change', stateArr.indexOf(state));
      }
    },
    handleScrollForStickyBar() {
      const scrollbar = this.$refs.scrollbar;
      if (!this.scrollBarSticky || !scrollbar) {
        return;
      }
      const scrollbarRect = scrollbar.$el.getBoundingClientRect();
      const scrollbarEl = scrollbar.$refs.horizontalBar.$el;
      const scrollParentElBottom = this.stickyBarScrollParentEl.getBoundingClientRect ?
        this.stickyBarScrollParentEl.getBoundingClientRect().bottom :
        this.stickyBarScrollParentEl.documentElement.clientHeight;
      if (scrollbarRect.bottom > scrollParentElBottom) {
        this.$el.appendChild(scrollbarEl);
        setStyles(scrollbarEl, {
          position: 'fixed',
          left: scrollbarRect.left + 'px'
        });
      } else {
        scrollbar.$refs.wrapper.appendChild(scrollbarEl);
        scrollbarEl.removeAttribute('style');
      }
    },
    sortColumnsOrder(columns) {
      const positiveList = columns.filter(column => column.order !== undefined && column.order >= 0).sort((a, b) => a.order - b.order);
      const freeList = columns.filter(column => column.order === undefined);
      const negativeList = columns.filter(column => column.order !== undefined && column.order < 0).sort((a, b) => a.order - b.order);
      const leftHalf = []; // positive order prioritized
      const rightHalf = []; // negative order prioritized
      let index = 0;
      const max = columns.length;
      while (leftHalf.length + rightHalf.length < max && index < max) {
        // fill the left half
        // the right positive order column -> the right negative order column -> free order column
        // the right order means that the order is equal or less than the index or index from end
        if (positiveList.length > 0 && positiveList[0].order <= index - 0) {
          leftHalf.push(positiveList.shift());
        } else if (negativeList.length > 0 &&  negativeList[0].order <= index - max) {
          leftHalf.push(negativeList.shift());
        } else if (freeList.length > 0) {
          leftHalf.push(freeList.shift());
        }

        // fill the right half
        // the right negative order column -> the right positive order column -> free order column
        // the right order means that the order is equal or more than the index or index from end
        if (negativeList.length > 0 && negativeList[negativeList.length - 1].order + 1 >= 0 - index) {
          rightHalf.push(negativeList.pop());
        } else if (positiveList.length > 0 && positiveList[positiveList.length - 1].order + 1 >= max - index) {
          rightHalf.push(positiveList.pop());
        } else if (freeList.length > 0)  {
          rightHalf.push(freeList.pop());
        }

        index++;
      }
      return leftHalf.concat(rightHalf.reverse());
    }
  }
};
</script>
