<template>
  <div class="shopee-modal">
    <transition name="fade-fast">
      <div class="shopee-modal__mask" ref="mask" v-show="visible">
        <div class="shopee-modal__container" ref="container" @click.self="cancelOnMask">
          <slot name="box">
            <shopee-modal-box v-bind="$props" @confirm="confirm" @cancel="cancel" @close="close">
              <slot></slot>
              <slot slot="header" name="header"></slot>
              <slot slot="content" name="content"></slot>
              <slot slot="footer" name="footer"></slot>
              <slot slot="footer-assist" name="footer-assist"></slot>
            </shopee-modal-box>
          </slot>
        </div>
      </div>
    </transition>
  </div>
</template>
<script>
import ShopeeModalBox from './box.vue';
import { PopupManager } from 'shopee-ui/lib/popper';
import { getScrollParent } from 'shopee-ui/lib/base';

export default {
  name: 'ShopeeModal',
  components: {
    ShopeeModalBox
  },
  props: {
    title: String,
    subtitle: String,
    content: String,
    visible: Boolean,
    classNames: Array,
    // size of modal: small, normal, medium, large and x-large
    size: String,
    width: Number,
    showCancel: {
      type: Boolean,
      default: true
    },
    showConfirm: {
      type: Boolean,
      default: true
    },
    center: Boolean,
    showClose: {
      type: Boolean,
      default: true
    },
    hasBack: Boolean,
    confirmText: String,
    cancelText: String,
    isConfirmDisabled: Boolean,
    isCancelDisabled: Boolean,
    isConfirmLoading: Boolean,
    isCancelLoading: Boolean,
    closeOnClickMask: Boolean,
    closeOnEsc: Boolean,

    // Modal props
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    appendToBody: {
      type: Boolean,
      default: false
    },
    emitClose: Boolean
  },
  watch: {
    closeOnEsc: {
      immediate: true,
      handler(val) {
        if (val) {
          document.addEventListener('keydown', this.cancelOnEsc);
        } else {
          document.removeEventListener('keydown', this.cancelOnEsc);
        }
      }
    },
    closeOnHashChange: {
      immediate: true,
      handler(val) {
        if (val) {
          window.addEventListener('hashchange', this.cancel);
        } else {
          window.removeEventListener('hashchange', this.cancel);
        }
      }
    },
    visible(val) {
      const maskRef = this.$refs.mask;
      if (val) {
        maskRef.style.zIndex = PopupManager.nextZIndex(true);
        maskRef.addEventListener('mousewheel', this.preventScroll);
      } else {
        maskRef.removeEventListener('mousewheel', this.preventScroll);
      }
    }
  },
  mounted() {
    if (this.appendToBody) {
      document.body.appendChild(this.$el);
    }
    this.$refs.mask.style.zIndex = PopupManager.nextZIndex(true);
    this.$refs.mask.addEventListener('mousewheel', this.preventScroll);
  },
  beforeDestroy() {
    if (this.closeOnEsc) {
      document.removeEventListener('keydown', this.cancelOnEsc);
    }
    if (this.closeOnHashChange) {
      window.removeEventListener('hashchange', this.cancel);
    }
    if (this.$refs.mask) {
      this.$refs.mask.removeEventListener('mousewheel', this.preventScroll);
    }
    if (this.appendToBody) {
      document.body.removeChild(this.$el);
    }
  },
  methods: {
    close() {
      this.$emit('close');
    },
    confirm(...args) {
      this.$emit('confirm', ...args);
    },
    cancel(...args) {
      this.$emit('cancel', ...args);
    },
    cancelOnEsc(e) {
      if (e.keyCode === 27 || e.which === 27) {
        this.cancel();
      }
    },
    cancelOnMask() {
      if (this.closeOnClickMask) {
        this.cancel();
      }
    },
    preventScroll(event) {
      const container = this.$refs.container;
      let prevent = true;
      // when scrollHeight of any scroll parent element belonging to container is greater than clientHeight,
      // the scroll event should be triggered normally
      // otherwise, the scroll event should be prevented
      let scrollElm = getScrollParent(event.target);
      while (container.contains(scrollElm)) {
        if (scrollElm.scrollHeight > scrollElm.clientHeight) {
          prevent = false;
          break;
        }
        scrollElm = getScrollParent(scrollElm.parentNode);
      }
      if (prevent) {
        event.preventDefault();
      }
    }
  }
};
</script>
