import ShopeeBox from './box.vue';
import { isVNode, isPromise, isFunction } from 'shopee-ui/lib/base';

let boxId = 0;

const modalSlots = {
  header: 'header',
  content: 'content',
  footer: 'footer',
  footerAssist: 'footer-assist'
};

class BoxInstance {
  constructor(config, modalInstance) {
    this.id = boxId++;
    this.created = false;
    this.visible = false;
    this.config = config;
    this.parentModal = modalInstance;
    this.render = this.genRender();
  }

  onCreate() {
    if (this.created) {
      return;
    }
    this.created = true;
    const config = this.config;
    this.bindManualConfig();
    // handle onCreate
    if (isFunction(config.onCreate)) {
      config.onCreate(this);
    }
    // auto close
    if (config.autoClose) {
      setTimeout(() => {
        this.destroyProxy(false);
      }, config.autoClose);
    }
  }

  genRender() {
    const self = this;
    const config = this.config;
    return function(h) {
      self.renderProxy = this;
      return h(ShopeeBox, {
        ref: 'box',
        slot: 'box',
        props: {
          ...config,
          visible: self.visible,
          content: typeof config.content === 'string' ? config.content : undefined
        },
        on: {
          confirm: self.confirm.bind(self),
          cancel: self.cancel.bind(self),
          close: self.close.bind(self)
        }
      }, self.renderSlots(h, config));
    };
  }

  renderSlots(h, config) {
    const slots = [];
    Object.keys(modalSlots).forEach(slotName => {
      let vNode = config[slotName];
      if (isFunction(vNode)) {
        vNode = config[slotName](this);
      }
      if (isVNode(vNode)) {
        const slot = modalSlots[slotName];
        slots.push(h('template', {
          slot
        }, [vNode]));
      }
    });
    return slots;
  }

  confirm(...args) {
    const config = this.config;
    if (isFunction(config.onConfirm)) {
      const res = config.onConfirm(this, ...args);
      // onConfirm return promise, toggle isConfirmLoading
      if (isPromise(res)) {
        this.isConfirmLoading = true;
        res.then(data => {
          this.isConfirmLoading = false;
          this.destroyProxy(true, data);
        }, () => {
          this.isConfirmLoading = false;
        });
      } else {
        if (res === true) {
          this.destroyProxy(true);
        }
      }
    } else {
      this.destroyProxy(true);
    }
  }

  close() {
    const config = this.config;
    if (isFunction(config.onClose)) {
      config.onClose();
    }
    this.destroyProxy(false);
  }

  cancel(...args) {
    const config = this.config;
    if (isFunction(config.onCancel)) {
      const res = config.onCancel(this, ...args);
      // onCancel return promise, toggle isCancelLoading
      if (isPromise(res)) {
        this.isCancelLoading = true;
        res.then(data => {
          this.isCancelLoading = false;
          this.destroyProxy(false, data);
        }, () => {
          this.isCancelLoading = false;
        });
      } else {
        this.destroyProxy(false, res);
      }
    } else {
      this.destroyProxy(false);
    }
  }

  update(config) {
    for (const key in config) {
      if (config.hasOwnProperty(key)) {
        this.config[key] = config[key];
      }
    }
  }

  bindManualConfig() {
    const props = ShopeeBox.props;
    for (const key in props) {
      if (props.hasOwnProperty(key) && key !== 'visible') {
        Object.defineProperty(this, key, {
          configurable: true,
          get() {
            return this.config[key];
          },
          set(value) {
            this.config[key] = value;
            if (this.renderProxy) {
              this.renderProxy.$forceUpdate();
            }
          }
        });
      }
    }
  }

  async destroyProxy(result, data) {
    await this.destroy();
    if (result) {
      this.resolve(data);
    } else {
      this.reject(data);
    }
  }

  async destroy(options) {
    this.visible = false;
    if (this.parentModal) {
      await this.parentModal.destroyBox.call(this.parentModal, this, options);
    }
  }

  async destroyAll(options) {
    if (this.parentModal) {
      await this.parentModal.destroyAll.call(this.parentModal, options);
    }
  }

  resolve() {}
  reject() {}
}

export default BoxInstance;
