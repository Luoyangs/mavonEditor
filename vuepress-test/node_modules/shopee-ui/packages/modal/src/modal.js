import BoxInstance from './box';
import ShopeeModal from './modal.vue';

const MOTION_TIME = 200;

class ModalInstance {
  constructor() {
    this.currentBox = null;
    this.vm = null;
  }

  initVm(Vue) {
    if (!this.vm) {
      this.vm = this.createVm(Vue);
    }
  }

  createVm(Vue) {
    const self = this;
    const Constructor = Vue.extend({
      data() {
        return {
          visible: false,
          closeOnClickMask: false,
          closeOnEsc: false,
          boxes: []
        };
      },
      render(h) {
        const slots = this.boxes.map(box => box.render.call(this._renderProxy, h));
        return h(ShopeeModal, {
          props: {
            visible: this.visible,
            closeOnClickMask: this.closeOnClickMask,
            closeOnEsc: this.closeOnEsc
          },
          on: {
            cancel: self.cancel.bind(self)
          }
        }, slots);
      }
    });
    return new Constructor().$mount();
  }

  async attachBox(box) {
    // show modal
    if (!this.vm.visible) {
      this.vm.visible = true;
      document.body.appendChild(this.vm.$el);
    }
    // show box
    this.vm.boxes.push(box);
    box.prev = this.currentBox;
    await this.switchBox(box, box.prev);
  }

  async destroyBox(box, options = {}) {
    // when options.nextInstance box or prev box exist, switch to the box
    // otherwise destroy all boxes in modal
    const getValidBox = (box) => box instanceof BoxInstance && this.vm.boxes.find(n => n.id === box.id);
    const poppingBox = getValidBox(options.nextInstance) || getValidBox(box.prev);
    if (poppingBox) {
      await this.switchBox(poppingBox, box);
      // destroy the box
      const index = this.vm.boxes.findIndex(n => n.id === box.id);
      if (index >= 0) {
        this.vm.boxes.splice(index, 1);
      }
    } else {
      await this.destroyAllBoxes();
    }
  }

  async destroyAll(options = {}) {
    if (this.vm) {
      const boxes = this.vm.boxes.filter(box => box.locked);
      if (boxes.length > 0 && !options.includeLocked) {
        if (!this.currentBox.locked) {
          const poppingBox = boxes[boxes.length - 1];
          await this.switchBox(poppingBox, this.currentBox);
        }
        this.vm.boxes = boxes;
      } else {
        await this.destroyAllBoxes();
      }
    }
  }

  switchBox(newBox, oldBox) {
    return new Promise(resolve => {
      // hide old box
      if (oldBox) {
        oldBox.visible = false;
      }
      // set new box to currentBox
      this.currentBox = newBox;
      // clear unexecuted show action
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      // show new box
      // delay MOTION_TIME when last box is existing or in animation
      this.timeout = setTimeout(() => {
        newBox.visible = true;
        newBox.onCreate();
        // update vm props
        this.vm.closeOnClickMask = newBox.config.closeOnClickMask;
        this.vm.closeOnEsc = newBox.config.closeOnEsc;
        resolve();
      }, this.displayingBox ? MOTION_TIME : 0);
      this.displayingBox = true;
    });
  }

  destroyAllBoxes() {
    if (this.vm) {
      return new Promise(resolve => {
        this.vm.visible = false;
        if (this.timeout) {
          clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(() => {
          this.currentBox = null;
          this.displayingBox = false;
          // destory modal
          if (this.vm && !this.vm.visible) {
            this.vm.boxes = [];
            document.body.removeChild(this.vm.$el);
            this.vm.$destroy();
            this.vm = null;
          }
          resolve();
        }, MOTION_TIME);
      });
    }
  }

  async cancel() {
    if (this.currentBox) {
      await this.destroyBox(this.currentBox);
      this.reject();
    }
  }

  open(Vue, config) {
    this.initVm(Vue);
    const box = new BoxInstance(config, this);
    this.attachBox(box);
    let outletInstance = box;
    const modal = this;
    // support return as Promise
    if (typeof Promise !== 'undefined') {
      outletInstance = new Promise((resolve, reject) => {
        box.resolve = resolve;
        box.reject = reject;
        modal.reject = reject;
      });
    }
    return outletInstance;
  }
}

export default ModalInstance;
