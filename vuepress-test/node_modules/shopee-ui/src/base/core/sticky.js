import { isObject, isFunction, getSupportedCSSProp, getScrollParent, setStyles } from '../utils';

/**
 * get numeric offset
 * @param {Object} offset
 */
function getNumericOffset(offset) {
  for (const key in offset) {
    if (offset[key] !== undefined) {
      const value = String(offset[key]);
      offset[key] = Number(value.match(/^\d*/));
    }
  }
  return offset;
}

/**
 * Format sticky offset
 * @param {Number, Object} offset
 */
function formatOffset(offset) {
  if (!isObject(offset)) {
    offset = { top: offset };
  }
  const { top, bottom, left, right } = offset;
  return getNumericOffset({ top, bottom, left, right });
}

const defaultOption = {
  /**
   * optional offset value:
   *   top
   *   {
   *     top,
   *     right,
   *     bottom,
   *     left
   *   }
   */
  offset: 0,
  onStateChange: null,
};

class Sticky {
  constructor(target, option = {}) {
    // get the sticky prop supported by browser
    const stickyProp = getSupportedCSSProp('position', 'sticky');
    this.supportSticky = !!stickyProp;
    // update option
    option = Object.assign({}, defaultOption, option);
    option.stickyProp = stickyProp;
    option.offset = formatOffset(option.offset);
    this.option = option;
    // init sticky instance
    this.instance = this.initInstance(target);
    this.updateInstance();
  }

  initInstance(el) {
    const instance = {
      el,
      parent: el.parentNode,
      scrollEl: getScrollParent(el),
    };
    if (this.supportSticky) {
      this.setStickyProp(instance);
    }
    instance.stateManager = () => this.manageState(instance);
    instance.scrollEl.addEventListener('scroll', instance.stateManager);
    return instance;
  }

  updateInstance() {
    const instance = this.instance;
    if (!instance) {
      return;
    }
    // add cumtom style
    const option = this.option;
    if (option.style) {
      setStyles(instance.el, {
        ...option.style
      });
    }
    // add stub elemnt for computed sticky state
    this.addStubElement(instance);
    // set and update default state
    instance.state = 'default';
    instance.stateManager();
  }

  setStickyProp(instance) {
    const option = this.option;
    setStyles(instance.el, {
      position: option.stickyProp,
      top: option.offset.top + 'px',
      bottom: option.offset.bottom + 'px',
      left: option.offset.left + 'px',
      right: option.offset.right + 'px'
    });
  }

  addStubElement(instance) {
    if (!instance.stub) {
      const el = instance.el;
      const stub = document.createElement('div');
      stub.className = 'sticky-assist';
      stub.style.display = instance.el.style.display;
      stub.style.willChange = 'width, height';
      el.parentNode.insertBefore(stub, el);
      instance.stub = stub;
    }
  }

  manageState(instance) {
    const { state, style } = this.computeState(instance);
    if (state !== instance.state) {
      instance.state = state;
      // update style
      if (style) {
        requestAnimationFrame(() => this.updateStyle(instance, style));
      }
      // call onStateChange
      const onStateChange = this.option.onStateChange;
      if (isFunction(onStateChange)) {
        onStateChange(instance.state);
      }
    }
  }

  // TODO: support left, right
  computeState(instance) {
    const isWin = instance.scrollEl === instance.el.ownerDocument;
    const offset = this.option.offset;
    const elRect = instance.el.getBoundingClientRect();
    const staticRect = instance.stub.getBoundingClientRect();
    const parentRect = instance.parent.getBoundingClientRect();
    const boundaryRect = !isWin ? instance.scrollEl.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };

    let state;
    let style = null;

    if (this.supportSticky) {
      const notSticky = elRect.top <= staticRect.top && elRect.bottom >= staticRect.top + elRect.height;
      const isStuck = elRect.bottom >= parentRect.bottom || elRect.top <= parentRect.top;
      const isSticky = !notSticky && !isStuck;
      state = isSticky ? 'sticky' : notSticky ? 'default' : isStuck && 'stuck';
    } else {
      const stickyOffsetTop = boundaryRect.top + (offset.top || 0);
      const stickyOffsetBottom = boundaryRect.bottom - (offset.bottom || 0);

      const isStuckTop = stickyOffsetBottom - elRect.height <= parentRect.top;
      const isStuckBottom = stickyOffsetTop + elRect.height >= parentRect.bottom;
      const isStickyTop = !isStuckBottom && staticRect.top <= stickyOffsetTop;
      const isStickyBottom = !isStuckTop && staticRect.top + elRect.height >= stickyOffsetBottom;
      const notSticky = staticRect.top >= stickyOffsetTop && staticRect.top + elRect.height <= stickyOffsetBottom;

      if ((isStuckTop || isStuckBottom)) {
        state = 'stuck';
        style = {
          position: 'relative',
          top: (isStuckBottom ? parentRect.height - elRect.height : 0) - (staticRect.top - parentRect.top) + 'px'
        };
      } else if (isStickyTop || isStickyBottom) {
        state = 'sticky';
        style = {
          position: 'fixed',
          boxSizing: 'border-box',
          width: elRect.width + 'px',
          top: (isStickyTop ? stickyOffsetTop : stickyOffsetBottom - elRect.height) + 'px',
          bottom: ''
        };
      } else if (notSticky) {
        state = 'default';
        style = {
          position: ''
        };
      }
    }

    return {
      state,
      style
    };
  }

  updateStyle(instance, style) {
    if (!this.supportSticky) {
      // update stub style
      const isSticky = instance.state === 'sticky';
      const elRect = instance.el.getBoundingClientRect();
      setStyles(instance.stub, {
        width: (isSticky ? elRect.width : 0) + 'px',
        height: (isSticky ? elRect.height : 0) + 'px'
      });
      // update el style
      setStyles(instance.el, style);
    }
  }

  update(stickyProps = {}) {
    if (Object.keys(stickyProps).length > 0) {
      const option = Object.assign({}, this.option, stickyProps);
      option.offset = formatOffset(stickyProps.offset);
      this.option = option;
      if (this.supportSticky) {
        this.setStickyProp(this.instance);
      }
    }

    this.updateInstance();
  }

  cleanup() {
    const instance = this.instance;
    instance.scrollEl.removeEventListener('scroll', instance.stateManager);
    instance.stub.parentNode.removeChild(instance.stub);
    this.instance = null;
  }
}

export default Sticky;
