/**
 * Get the browser supported attribute and the value of the attribute
 * @param {String} attr
 * @param {String} value
 * @returns supported attribute value or false
 */
export function getSupportedCSSProp(attr, value) {
  var element = document.createElement('div');
  if (attr in element.style) {
    const prefixs = ['', '-webkit-', '-moz-', '-o-', '-ms-'];
    for (let i = 0; i < prefixs.length; i++) {
      const prop = prefixs[i] + value;
      element.style[attr] = prop;
      if (element.style[attr] === prop) {
        return prop;
      }
    }
  }
  return false;
}

/**
 * Set the style to the given element
 * @param {Element} element
 * @param {Object} styles
 */
export function setStyles(element, styles) {
  Object.keys(styles).forEach(prop => {
    element.style[prop] = styles[prop];
  });
}

/**
 * Returns the scrolling parent of the given element
 * @param {Element} element
 * @returns {Element} scroll parent
 */
export function getScrollParent(element) {
  if (!element) {
    return document;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
    case '#document':
      return element.ownerDocument;
  }

  // Firefox want us to check `-x` and `-y` variations as well
  const { overflow, overflowX, overflowY } = getComputedStyle(element, null);
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(element.parentNode);
}

/**
 * Returns the element is has the given class
 */
export function hasClass(el, cls) {
  if (!el || !cls) {
    return false;
  }
  if (cls.indexOf(' ') !== -1) {
    throw new Error('className should not contain space.');
  }
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}

/**
 * the element add the given class
 */
export function addClass(el, cls) {
  if (!el) {
    return;
  }
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) {
      continue;
    }
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}

/**
 * the element remove the given class
 */
export function removeClass(el, cls) {
  if (!el || !cls) {
    return;
  }
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) {
      continue;
    }
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }
  if (!el.classList) {
    el.className = curClass.trim();
  }
}
// scrollTop animation
export function scrollTop(el, from = 0, to, duration = 500, endCallback) {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function (callback) {
        // 1000 / 60 = 16.67 模拟window.requestAnimationFrame更新帧的频率
        return window.setTimeout(callback, 16.67);
      }
    );
  }
  const difference = Math.abs(from - to);
  const step = Math.ceil(difference / duration * 50);

  function scroll(start, end, step) {
    if (start === end) {
      endCallback && endCallback();
      return;
    }

    let d = (start + step > end) ? end : start + step;
    if (start > end) {
      d = (start - step < end) ? end : start - step;
    }

    if (el === window) {
      window.scrollTo(d, d);
    } else {
      el.scrollTop = d;
    }
    window.requestAnimationFrame(() => scroll(d, end, step));
  }

  scroll(from, to, step);
}
