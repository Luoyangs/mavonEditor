const toString = Object.prototype.toString;

export function noop() {}

/**
 * Simple object check.
 * @param object the given object
 * @returns {boolean}
 */
export function isObject(object) {
  return object !== null && typeof object === 'object';
}

export function isArray(arr) {
  return arr && toString.call(arr) === '[object Array]';
}

/**
 * Check if the given variable is a function
 * @param {*} func the given variable
 * @returns {Boolean} answer to: is a function?
 */
export function isFunction(func) {
  return func && func instanceof Function;
}

/**
 * whether the object is a Promise
 * @param  {Object}  promise the given object
 * @return {Boolean} whether the given object is a Promise
 */
export function isPromise(promise) {
  return promise && isFunction(promise.then);
}

/**
 * whether the object is a Regular Expression
 * @param {Object} object the given object
 * @return {Boolean}
 */
export function isRegExp(object) {
  return object && toString.call(object) === '[object RegExp]';
}

/**
 * whether the date is a valid date
 * @param {Object} date the given date
 * @return {Boolean}
 */
export function isValidDate(date) {
  return toString.call(date) === '[object Date]' && date.toString() !== 'Invalid Date';
}

/**
 * whether the object is a vue instance
 * @param {Object} object the given object
 * @return {Boolean}
 */
export function isVueInstance(object) {
  return object && isObject(object) && object._isVue;
}

/**
 * whether the node is a vnode
 * @param  {Object}  node the given node
 * @return {Boolean} whether the given node is a vnode
 */
export function isVNode(node) {
  return typeof node === 'object' && node.hasOwnProperty('componentOptions');
}

/**
 * calculate the string length of Unicode
 *  https://git.garena.com/shopee-sz-fe/vue-ui/-/issues/131
 * @param  {Object}  str
 * @return
 */
export function lengthOf(str) {
  if (typeof str === 'number' || typeof str === 'string') {
    const reg = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    return String(str).replace(reg, ' ').length;
  }
  return str.length;
}

/**
 * slice the string length of Unicode
 *  https://git.garena.com/shopee-sz-fe/vue-ui/-/issues/131
 * @param  {Object}  str
 * @return
 */
export function sliceStr(str, min, max) {
  if (typeof str === 'number' || typeof str === 'string') {
    if (String(str).length === 0) {
      return '';
    }
    // eslint-disable-next-line no-control-regex
    const reg = /[\uD800-\uDBFF][\uDC00-\uDFFF]|[\u0000-\uFFFF]/g;
    return String(str).match(reg).slice(min, max).join('');
  }
  return '';
}

/**
 * merge object
 * @param  {Object} target the target object
 * @return {Object} the object after merged
 */
export function merge(target) {
  for (let i = 1, j = arguments.length; i < j; i++) {
    let source = arguments[i] || {};
    for (let prop in source) {
      if (source.hasOwnProperty(prop)) {
        let value = source[prop];
        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
}

/**
 * Deep merge two objects.
 * @param target
 * @param ...sources
 */
export function mergeDeep(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) {
          Object.assign(target, {
            [key]: isArray(source[key]) ? [] : {}
          });
        }
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, {
          [key]: source[key]
        });
      }
    }
  }

  return mergeDeep(target, ...sources);
}

/**
 * Returns a throttled function that only invokes {fn} at most once per every {interval} milliseconds
 * @param fn function to be throttled
 * @param interval throttle interval in milliseconds
 * @returns {Function} throttled version of this fn
 */
export function throttle(fn, interval) {
  let isThrottling = false;

  return function () {
    const context = this;

    if (!isThrottling) {
      fn.apply(context, arguments);
      isThrottling = true;

      setTimeout(() => {
        isThrottling = false;
      }, interval);
    }
  };
}

/**
 * Returns a debounced function that delays invoking {fn} until after
 * {delay} milliseconds have elapsed since the last time the debounced function was invoked
 * @param fn function to be debounced
 * @param delay delay timing for execution in milliseconds
 * @returns {Function} debounced version of this fn
 */
export function debounce(fn, delay) {
  let timeout = null;

  return function () {
    const context = this;
    const args = arguments;

    timeout && clearTimeout(timeout);

    timeout = setTimeout(fn.bind(context, ...args), delay);
  };
}
