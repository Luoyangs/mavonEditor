<template>
  <transition :name="transitionName">
    <div class="shopee-popper" v-show="visible"><slot></slot></div>
  </transition>
</template>
<script>
import PopperJS from 'popper.js';
import PopupManager from './popup-manager';
import { PLACEMENTS } from 'shopee-ui/lib/base';

const stopPropagation = e => e.stopPropagation();

export default {
  name: 'ShopeePopper',
  props: {
    visible: Boolean,
    appendToBody: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: 'auto',
      validator(val) {
        return PLACEMENTS.indexOf(val) !== -1;
      }
    },
    flippable: {
      type: Boolean,
      default: true
    },
    limitedFlip: {
      type: Boolean,
      default: false
    },
    transitionName: {
      type: String,
      default: 'slide-fast',
    },
    flipVariationsByContent: {
      type: Boolean,
      default: false
    },
    popperRef: {}
  },
  computed: {
    computedPopperRef() {
      if (this.popperRef) {
        if (typeof this.popperRef === 'function') {
          return this.popperRef();
        } else {
          return this.popperRef;
        }
      }
      let parent = this.$parent;
      while (parent && !parent.$refs.popperRef) {
        parent = parent.$parent;
      }
      if (parent) {
        return parent.$refs.popperRef;
      }
      return;
    },
    isInModal() {
      let parent = this.$parent;
      while (parent && parent.$options.name !== 'ShopeeModal') {
        parent = parent.$parent;
      }
      return !!parent;
    },
    transformOriginMap() {
      return {
        'top-start': 'left bottom',
        'top': 'center bottom',
        'top-end': 'right bottom',
        'bottom-start': 'left top',
        'bottom': 'center top',
        'bottom-end': 'right top',
        'left-start': 'top right',
        'left': 'center right',
        'left-end': 'bottom right',
        'right-start': 'top left',
        'right': 'center left',
        'right-end': 'bottom left'
      };
    },
    placementBehavior() { // adjusting placement when overflow the boundry. ps: top-start, right-end...that has suffix does not work
      const [position] = this.placement.split('-');
      const map = {
        auto: ['bottom', 'top', 'right', 'left'],
        top: ['top', 'bottom', 'right', 'left'],
        bottom: ['bottom', 'top', 'right', 'left'],
        right: ['right', 'left', 'bottom', 'top'],
        left: ['left', 'right', 'bottom', 'top']
      };
      let behavior = map[position];
      return behavior;
    },
    limitedPlacementBehavior() { // adjusting placement when overflow the boundry. ps: top-start, right-end...that has suffix does not work
      const [position] = this.placement.split('-');
      const map = {
        auto: ['bottom', 'top', 'right', 'left'],
        top: ['top', 'bottom'],
        bottom: ['bottom', 'top'],
        right: ['right', 'left'],
        left: ['left', 'right']
      };
      let behavior = map[position];
      return behavior;
    }
  },
  watch: {
    visible(value) {
      if (value) {
        if (!this.popper) {
          this.createPopper();
        } else {
          this.updatePopper();
        }
      }
    }
  },
  destroyed() {
    if (this.popper) {
      this.destroyPopper();
      if (this.appendToBody) {
        document.body.removeChild(this.$el);
      }
    }
  },
  methods: {
    createPopper() {
      if (!this.computedPopperRef) {
        return;
      }
      if (this.appendToBody) {
        document.body.appendChild(this.$el);
      }
      let popperRef = this.computedPopperRef.$el ? this.computedPopperRef.$el : this.computedPopperRef;
      this.popper = new PopperJS(popperRef, this.$el, {
        placement: this.placement,
        modifiers: {
          computeStyle: {
            gpuAcceleration: false
          },
          preventOverflow: {
            boundariesElement: 'body',
            padding: 0
          },
          flip: {
            enabled: this.flippable,
            behavior: this.limitedFlip ? this.limitedPlacementBehavior : this.placementBehavior,
            boundariesElement: this.flipVariationsByContent ? 'window' : 'viewport',
            flipVariationsByContent: this.flipVariationsByContent
          }
        },
        onCreate: () => {
          this.resetTransformOrigin();
          this.$nextTick(() => {
            this.updatePopper();
          });
        },
        onUpdate: () => {
          this.resetTransformOrigin();
        }
      });
      this.popper.popper.style.zIndex = this.appendToBody ? PopupManager.nextZIndex(this.isInModal) : 1;
      this.$el.addEventListener('click', stopPropagation);
    },
    resetTransformOrigin() {
      if (this.popper) {
        let placement = this.popper.popper.getAttribute('x-placement');
        this.popper.popper.style.transformOrigin = this.transformOriginMap[placement];
      }
    },
    updatePopper() {
      if (this.popper) {
        this.popper.update();
        this.popper.popper.style.zIndex = this.appendToBody ? PopupManager.nextZIndex(this.isInModal) : 1;
      }
    },
    destroyPopper() {
      if (this.popper) {
        this.popper.destroy();
        this.$el.removeEventListener('click', stopPropagation);
      }
    }
  }
};
</script>
